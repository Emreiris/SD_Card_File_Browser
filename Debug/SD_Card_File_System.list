
SD_Card_File_System.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002554  080001c8  080001c8  000101c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000018  0800271c  0800271c  0001271c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08002734  08002734  0002000c  2**0
                  CONTENTS
  4 .ARM          00000008  08002734  08002734  00012734  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0800273c  0800273c  0002000c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   0000000c  0800273c  0800273c  0001273c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08002748  08002748  00012748  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000000c  20000000  0800274c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000057c  2000000c  08002758  0002000c  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20000588  08002758  00020588  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  0002000c  2**0
                  CONTENTS, READONLY
 12 .debug_info   00039ad7  00000000  00000000  0002003c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00005890  00000000  00000000  00059b13  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000e48  00000000  00000000  0005f3a8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 000032a0  00000000  00000000  000601f0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  000064e4  00000000  00000000  00063490  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   00027bb1  00000000  00000000  00069974  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    0010ec81  00000000  00000000  00091525  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000053  00000000  00000000  001a01a6  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00003418  00000000  00000000  001a01fc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_loc    000190f0  00000000  00000000  001a3614  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001c8 <__do_global_dtors_aux>:
 80001c8:	b510      	push	{r4, lr}
 80001ca:	4c05      	ldr	r4, [pc, #20]	; (80001e0 <__do_global_dtors_aux+0x18>)
 80001cc:	7823      	ldrb	r3, [r4, #0]
 80001ce:	b933      	cbnz	r3, 80001de <__do_global_dtors_aux+0x16>
 80001d0:	4b04      	ldr	r3, [pc, #16]	; (80001e4 <__do_global_dtors_aux+0x1c>)
 80001d2:	b113      	cbz	r3, 80001da <__do_global_dtors_aux+0x12>
 80001d4:	4804      	ldr	r0, [pc, #16]	; (80001e8 <__do_global_dtors_aux+0x20>)
 80001d6:	f3af 8000 	nop.w
 80001da:	2301      	movs	r3, #1
 80001dc:	7023      	strb	r3, [r4, #0]
 80001de:	bd10      	pop	{r4, pc}
 80001e0:	2000000c 	.word	0x2000000c
 80001e4:	00000000 	.word	0x00000000
 80001e8:	08002704 	.word	0x08002704

080001ec <frame_dummy>:
 80001ec:	b508      	push	{r3, lr}
 80001ee:	4b03      	ldr	r3, [pc, #12]	; (80001fc <frame_dummy+0x10>)
 80001f0:	b11b      	cbz	r3, 80001fa <frame_dummy+0xe>
 80001f2:	4903      	ldr	r1, [pc, #12]	; (8000200 <frame_dummy+0x14>)
 80001f4:	4803      	ldr	r0, [pc, #12]	; (8000204 <frame_dummy+0x18>)
 80001f6:	f3af 8000 	nop.w
 80001fa:	bd08      	pop	{r3, pc}
 80001fc:	00000000 	.word	0x00000000
 8000200:	20000010 	.word	0x20000010
 8000204:	08002704 	.word	0x08002704

08000208 <__aeabi_uldivmod>:
 8000208:	b953      	cbnz	r3, 8000220 <__aeabi_uldivmod+0x18>
 800020a:	b94a      	cbnz	r2, 8000220 <__aeabi_uldivmod+0x18>
 800020c:	2900      	cmp	r1, #0
 800020e:	bf08      	it	eq
 8000210:	2800      	cmpeq	r0, #0
 8000212:	bf1c      	itt	ne
 8000214:	f04f 31ff 	movne.w	r1, #4294967295
 8000218:	f04f 30ff 	movne.w	r0, #4294967295
 800021c:	f000 b96e 	b.w	80004fc <__aeabi_idiv0>
 8000220:	f1ad 0c08 	sub.w	ip, sp, #8
 8000224:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000228:	f000 f806 	bl	8000238 <__udivmoddi4>
 800022c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000230:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000234:	b004      	add	sp, #16
 8000236:	4770      	bx	lr

08000238 <__udivmoddi4>:
 8000238:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800023c:	9d08      	ldr	r5, [sp, #32]
 800023e:	4604      	mov	r4, r0
 8000240:	468c      	mov	ip, r1
 8000242:	2b00      	cmp	r3, #0
 8000244:	f040 8083 	bne.w	800034e <__udivmoddi4+0x116>
 8000248:	428a      	cmp	r2, r1
 800024a:	4617      	mov	r7, r2
 800024c:	d947      	bls.n	80002de <__udivmoddi4+0xa6>
 800024e:	fab2 f282 	clz	r2, r2
 8000252:	b142      	cbz	r2, 8000266 <__udivmoddi4+0x2e>
 8000254:	f1c2 0020 	rsb	r0, r2, #32
 8000258:	fa24 f000 	lsr.w	r0, r4, r0
 800025c:	4091      	lsls	r1, r2
 800025e:	4097      	lsls	r7, r2
 8000260:	ea40 0c01 	orr.w	ip, r0, r1
 8000264:	4094      	lsls	r4, r2
 8000266:	ea4f 4817 	mov.w	r8, r7, lsr #16
 800026a:	0c23      	lsrs	r3, r4, #16
 800026c:	fbbc f6f8 	udiv	r6, ip, r8
 8000270:	fa1f fe87 	uxth.w	lr, r7
 8000274:	fb08 c116 	mls	r1, r8, r6, ip
 8000278:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800027c:	fb06 f10e 	mul.w	r1, r6, lr
 8000280:	4299      	cmp	r1, r3
 8000282:	d909      	bls.n	8000298 <__udivmoddi4+0x60>
 8000284:	18fb      	adds	r3, r7, r3
 8000286:	f106 30ff 	add.w	r0, r6, #4294967295
 800028a:	f080 8119 	bcs.w	80004c0 <__udivmoddi4+0x288>
 800028e:	4299      	cmp	r1, r3
 8000290:	f240 8116 	bls.w	80004c0 <__udivmoddi4+0x288>
 8000294:	3e02      	subs	r6, #2
 8000296:	443b      	add	r3, r7
 8000298:	1a5b      	subs	r3, r3, r1
 800029a:	b2a4      	uxth	r4, r4
 800029c:	fbb3 f0f8 	udiv	r0, r3, r8
 80002a0:	fb08 3310 	mls	r3, r8, r0, r3
 80002a4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 80002a8:	fb00 fe0e 	mul.w	lr, r0, lr
 80002ac:	45a6      	cmp	lr, r4
 80002ae:	d909      	bls.n	80002c4 <__udivmoddi4+0x8c>
 80002b0:	193c      	adds	r4, r7, r4
 80002b2:	f100 33ff 	add.w	r3, r0, #4294967295
 80002b6:	f080 8105 	bcs.w	80004c4 <__udivmoddi4+0x28c>
 80002ba:	45a6      	cmp	lr, r4
 80002bc:	f240 8102 	bls.w	80004c4 <__udivmoddi4+0x28c>
 80002c0:	3802      	subs	r0, #2
 80002c2:	443c      	add	r4, r7
 80002c4:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 80002c8:	eba4 040e 	sub.w	r4, r4, lr
 80002cc:	2600      	movs	r6, #0
 80002ce:	b11d      	cbz	r5, 80002d8 <__udivmoddi4+0xa0>
 80002d0:	40d4      	lsrs	r4, r2
 80002d2:	2300      	movs	r3, #0
 80002d4:	e9c5 4300 	strd	r4, r3, [r5]
 80002d8:	4631      	mov	r1, r6
 80002da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002de:	b902      	cbnz	r2, 80002e2 <__udivmoddi4+0xaa>
 80002e0:	deff      	udf	#255	; 0xff
 80002e2:	fab2 f282 	clz	r2, r2
 80002e6:	2a00      	cmp	r2, #0
 80002e8:	d150      	bne.n	800038c <__udivmoddi4+0x154>
 80002ea:	1bcb      	subs	r3, r1, r7
 80002ec:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 80002f0:	fa1f f887 	uxth.w	r8, r7
 80002f4:	2601      	movs	r6, #1
 80002f6:	fbb3 fcfe 	udiv	ip, r3, lr
 80002fa:	0c21      	lsrs	r1, r4, #16
 80002fc:	fb0e 331c 	mls	r3, lr, ip, r3
 8000300:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000304:	fb08 f30c 	mul.w	r3, r8, ip
 8000308:	428b      	cmp	r3, r1
 800030a:	d907      	bls.n	800031c <__udivmoddi4+0xe4>
 800030c:	1879      	adds	r1, r7, r1
 800030e:	f10c 30ff 	add.w	r0, ip, #4294967295
 8000312:	d202      	bcs.n	800031a <__udivmoddi4+0xe2>
 8000314:	428b      	cmp	r3, r1
 8000316:	f200 80e9 	bhi.w	80004ec <__udivmoddi4+0x2b4>
 800031a:	4684      	mov	ip, r0
 800031c:	1ac9      	subs	r1, r1, r3
 800031e:	b2a3      	uxth	r3, r4
 8000320:	fbb1 f0fe 	udiv	r0, r1, lr
 8000324:	fb0e 1110 	mls	r1, lr, r0, r1
 8000328:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
 800032c:	fb08 f800 	mul.w	r8, r8, r0
 8000330:	45a0      	cmp	r8, r4
 8000332:	d907      	bls.n	8000344 <__udivmoddi4+0x10c>
 8000334:	193c      	adds	r4, r7, r4
 8000336:	f100 33ff 	add.w	r3, r0, #4294967295
 800033a:	d202      	bcs.n	8000342 <__udivmoddi4+0x10a>
 800033c:	45a0      	cmp	r8, r4
 800033e:	f200 80d9 	bhi.w	80004f4 <__udivmoddi4+0x2bc>
 8000342:	4618      	mov	r0, r3
 8000344:	eba4 0408 	sub.w	r4, r4, r8
 8000348:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 800034c:	e7bf      	b.n	80002ce <__udivmoddi4+0x96>
 800034e:	428b      	cmp	r3, r1
 8000350:	d909      	bls.n	8000366 <__udivmoddi4+0x12e>
 8000352:	2d00      	cmp	r5, #0
 8000354:	f000 80b1 	beq.w	80004ba <__udivmoddi4+0x282>
 8000358:	2600      	movs	r6, #0
 800035a:	e9c5 0100 	strd	r0, r1, [r5]
 800035e:	4630      	mov	r0, r6
 8000360:	4631      	mov	r1, r6
 8000362:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000366:	fab3 f683 	clz	r6, r3
 800036a:	2e00      	cmp	r6, #0
 800036c:	d14a      	bne.n	8000404 <__udivmoddi4+0x1cc>
 800036e:	428b      	cmp	r3, r1
 8000370:	d302      	bcc.n	8000378 <__udivmoddi4+0x140>
 8000372:	4282      	cmp	r2, r0
 8000374:	f200 80b8 	bhi.w	80004e8 <__udivmoddi4+0x2b0>
 8000378:	1a84      	subs	r4, r0, r2
 800037a:	eb61 0103 	sbc.w	r1, r1, r3
 800037e:	2001      	movs	r0, #1
 8000380:	468c      	mov	ip, r1
 8000382:	2d00      	cmp	r5, #0
 8000384:	d0a8      	beq.n	80002d8 <__udivmoddi4+0xa0>
 8000386:	e9c5 4c00 	strd	r4, ip, [r5]
 800038a:	e7a5      	b.n	80002d8 <__udivmoddi4+0xa0>
 800038c:	f1c2 0320 	rsb	r3, r2, #32
 8000390:	fa20 f603 	lsr.w	r6, r0, r3
 8000394:	4097      	lsls	r7, r2
 8000396:	fa01 f002 	lsl.w	r0, r1, r2
 800039a:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 800039e:	40d9      	lsrs	r1, r3
 80003a0:	4330      	orrs	r0, r6
 80003a2:	0c03      	lsrs	r3, r0, #16
 80003a4:	fbb1 f6fe 	udiv	r6, r1, lr
 80003a8:	fa1f f887 	uxth.w	r8, r7
 80003ac:	fb0e 1116 	mls	r1, lr, r6, r1
 80003b0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80003b4:	fb06 f108 	mul.w	r1, r6, r8
 80003b8:	4299      	cmp	r1, r3
 80003ba:	fa04 f402 	lsl.w	r4, r4, r2
 80003be:	d909      	bls.n	80003d4 <__udivmoddi4+0x19c>
 80003c0:	18fb      	adds	r3, r7, r3
 80003c2:	f106 3cff 	add.w	ip, r6, #4294967295
 80003c6:	f080 808d 	bcs.w	80004e4 <__udivmoddi4+0x2ac>
 80003ca:	4299      	cmp	r1, r3
 80003cc:	f240 808a 	bls.w	80004e4 <__udivmoddi4+0x2ac>
 80003d0:	3e02      	subs	r6, #2
 80003d2:	443b      	add	r3, r7
 80003d4:	1a5b      	subs	r3, r3, r1
 80003d6:	b281      	uxth	r1, r0
 80003d8:	fbb3 f0fe 	udiv	r0, r3, lr
 80003dc:	fb0e 3310 	mls	r3, lr, r0, r3
 80003e0:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80003e4:	fb00 f308 	mul.w	r3, r0, r8
 80003e8:	428b      	cmp	r3, r1
 80003ea:	d907      	bls.n	80003fc <__udivmoddi4+0x1c4>
 80003ec:	1879      	adds	r1, r7, r1
 80003ee:	f100 3cff 	add.w	ip, r0, #4294967295
 80003f2:	d273      	bcs.n	80004dc <__udivmoddi4+0x2a4>
 80003f4:	428b      	cmp	r3, r1
 80003f6:	d971      	bls.n	80004dc <__udivmoddi4+0x2a4>
 80003f8:	3802      	subs	r0, #2
 80003fa:	4439      	add	r1, r7
 80003fc:	1acb      	subs	r3, r1, r3
 80003fe:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 8000402:	e778      	b.n	80002f6 <__udivmoddi4+0xbe>
 8000404:	f1c6 0c20 	rsb	ip, r6, #32
 8000408:	fa03 f406 	lsl.w	r4, r3, r6
 800040c:	fa22 f30c 	lsr.w	r3, r2, ip
 8000410:	431c      	orrs	r4, r3
 8000412:	fa20 f70c 	lsr.w	r7, r0, ip
 8000416:	fa01 f306 	lsl.w	r3, r1, r6
 800041a:	ea4f 4e14 	mov.w	lr, r4, lsr #16
 800041e:	fa21 f10c 	lsr.w	r1, r1, ip
 8000422:	431f      	orrs	r7, r3
 8000424:	0c3b      	lsrs	r3, r7, #16
 8000426:	fbb1 f9fe 	udiv	r9, r1, lr
 800042a:	fa1f f884 	uxth.w	r8, r4
 800042e:	fb0e 1119 	mls	r1, lr, r9, r1
 8000432:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8000436:	fb09 fa08 	mul.w	sl, r9, r8
 800043a:	458a      	cmp	sl, r1
 800043c:	fa02 f206 	lsl.w	r2, r2, r6
 8000440:	fa00 f306 	lsl.w	r3, r0, r6
 8000444:	d908      	bls.n	8000458 <__udivmoddi4+0x220>
 8000446:	1861      	adds	r1, r4, r1
 8000448:	f109 30ff 	add.w	r0, r9, #4294967295
 800044c:	d248      	bcs.n	80004e0 <__udivmoddi4+0x2a8>
 800044e:	458a      	cmp	sl, r1
 8000450:	d946      	bls.n	80004e0 <__udivmoddi4+0x2a8>
 8000452:	f1a9 0902 	sub.w	r9, r9, #2
 8000456:	4421      	add	r1, r4
 8000458:	eba1 010a 	sub.w	r1, r1, sl
 800045c:	b2bf      	uxth	r7, r7
 800045e:	fbb1 f0fe 	udiv	r0, r1, lr
 8000462:	fb0e 1110 	mls	r1, lr, r0, r1
 8000466:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 800046a:	fb00 f808 	mul.w	r8, r0, r8
 800046e:	45b8      	cmp	r8, r7
 8000470:	d907      	bls.n	8000482 <__udivmoddi4+0x24a>
 8000472:	19e7      	adds	r7, r4, r7
 8000474:	f100 31ff 	add.w	r1, r0, #4294967295
 8000478:	d22e      	bcs.n	80004d8 <__udivmoddi4+0x2a0>
 800047a:	45b8      	cmp	r8, r7
 800047c:	d92c      	bls.n	80004d8 <__udivmoddi4+0x2a0>
 800047e:	3802      	subs	r0, #2
 8000480:	4427      	add	r7, r4
 8000482:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000486:	eba7 0708 	sub.w	r7, r7, r8
 800048a:	fba0 8902 	umull	r8, r9, r0, r2
 800048e:	454f      	cmp	r7, r9
 8000490:	46c6      	mov	lr, r8
 8000492:	4649      	mov	r1, r9
 8000494:	d31a      	bcc.n	80004cc <__udivmoddi4+0x294>
 8000496:	d017      	beq.n	80004c8 <__udivmoddi4+0x290>
 8000498:	b15d      	cbz	r5, 80004b2 <__udivmoddi4+0x27a>
 800049a:	ebb3 020e 	subs.w	r2, r3, lr
 800049e:	eb67 0701 	sbc.w	r7, r7, r1
 80004a2:	fa07 fc0c 	lsl.w	ip, r7, ip
 80004a6:	40f2      	lsrs	r2, r6
 80004a8:	ea4c 0202 	orr.w	r2, ip, r2
 80004ac:	40f7      	lsrs	r7, r6
 80004ae:	e9c5 2700 	strd	r2, r7, [r5]
 80004b2:	2600      	movs	r6, #0
 80004b4:	4631      	mov	r1, r6
 80004b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80004ba:	462e      	mov	r6, r5
 80004bc:	4628      	mov	r0, r5
 80004be:	e70b      	b.n	80002d8 <__udivmoddi4+0xa0>
 80004c0:	4606      	mov	r6, r0
 80004c2:	e6e9      	b.n	8000298 <__udivmoddi4+0x60>
 80004c4:	4618      	mov	r0, r3
 80004c6:	e6fd      	b.n	80002c4 <__udivmoddi4+0x8c>
 80004c8:	4543      	cmp	r3, r8
 80004ca:	d2e5      	bcs.n	8000498 <__udivmoddi4+0x260>
 80004cc:	ebb8 0e02 	subs.w	lr, r8, r2
 80004d0:	eb69 0104 	sbc.w	r1, r9, r4
 80004d4:	3801      	subs	r0, #1
 80004d6:	e7df      	b.n	8000498 <__udivmoddi4+0x260>
 80004d8:	4608      	mov	r0, r1
 80004da:	e7d2      	b.n	8000482 <__udivmoddi4+0x24a>
 80004dc:	4660      	mov	r0, ip
 80004de:	e78d      	b.n	80003fc <__udivmoddi4+0x1c4>
 80004e0:	4681      	mov	r9, r0
 80004e2:	e7b9      	b.n	8000458 <__udivmoddi4+0x220>
 80004e4:	4666      	mov	r6, ip
 80004e6:	e775      	b.n	80003d4 <__udivmoddi4+0x19c>
 80004e8:	4630      	mov	r0, r6
 80004ea:	e74a      	b.n	8000382 <__udivmoddi4+0x14a>
 80004ec:	f1ac 0c02 	sub.w	ip, ip, #2
 80004f0:	4439      	add	r1, r7
 80004f2:	e713      	b.n	800031c <__udivmoddi4+0xe4>
 80004f4:	3802      	subs	r0, #2
 80004f6:	443c      	add	r4, r7
 80004f8:	e724      	b.n	8000344 <__udivmoddi4+0x10c>
 80004fa:	bf00      	nop

080004fc <__aeabi_idiv0>:
 80004fc:	4770      	bx	lr
 80004fe:	bf00      	nop

08000500 <_ZN9displayerC1Ev>:
#define LCD_DISP_STATE(x) \
	HAL_GPIO_WritePin(GPIOI, GPIO_PIN_12, x)

#define FB_START_ADDRRESS ((uint32_t)0xC0000000)

displayer::displayer()
 8000500:	b480      	push	{r7}
 8000502:	b083      	sub	sp, #12
 8000504:	af00      	add	r7, sp, #0
 8000506:	6078      	str	r0, [r7, #4]
{
	; /*TODO : It may be filled later.*/
}
 8000508:	687b      	ldr	r3, [r7, #4]
 800050a:	4618      	mov	r0, r3
 800050c:	370c      	adds	r7, #12
 800050e:	46bd      	mov	sp, r7
 8000510:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000514:	4770      	bx	lr

08000516 <_ZN13sdram_handlerC1Ev>:

class sdram_handler
{

public:
	sdram_handler()
 8000516:	b480      	push	{r7}
 8000518:	b083      	sub	sp, #12
 800051a:	af00      	add	r7, sp, #0
 800051c:	6078      	str	r0, [r7, #4]
	{
	}
 800051e:	687b      	ldr	r3, [r7, #4]
 8000520:	4618      	mov	r0, r3
 8000522:	370c      	adds	r7, #12
 8000524:	46bd      	mov	sp, r7
 8000526:	f85d 7b04 	ldr.w	r7, [sp], #4
 800052a:	4770      	bx	lr

0800052c <_Z41__static_initialization_and_destruction_0ii>:
            color_p++;
        }
    }

    lv_disp_flush_ready(disp);
}
 800052c:	b580      	push	{r7, lr}
 800052e:	b082      	sub	sp, #8
 8000530:	af00      	add	r7, sp, #0
 8000532:	6078      	str	r0, [r7, #4]
 8000534:	6039      	str	r1, [r7, #0]
 8000536:	687b      	ldr	r3, [r7, #4]
 8000538:	2b01      	cmp	r3, #1
 800053a:	d107      	bne.n	800054c <_Z41__static_initialization_and_destruction_0ii+0x20>
 800053c:	683b      	ldr	r3, [r7, #0]
 800053e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000542:	4293      	cmp	r3, r2
 8000544:	d102      	bne.n	800054c <_Z41__static_initialization_and_destruction_0ii+0x20>
static displayer display;
 8000546:	4803      	ldr	r0, [pc, #12]	; (8000554 <_Z41__static_initialization_and_destruction_0ii+0x28>)
 8000548:	f7ff ffda 	bl	8000500 <_ZN9displayerC1Ev>
}
 800054c:	bf00      	nop
 800054e:	3708      	adds	r7, #8
 8000550:	46bd      	mov	sp, r7
 8000552:	bd80      	pop	{r7, pc}
 8000554:	20000028 	.word	0x20000028

08000558 <_GLOBAL__sub_I__ZN20displayer_gui_driver8gui_initEv>:
 8000558:	b580      	push	{r7, lr}
 800055a:	af00      	add	r7, sp, #0
 800055c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8000560:	2001      	movs	r0, #1
 8000562:	f7ff ffe3 	bl	800052c <_Z41__static_initialization_and_destruction_0ii>
 8000566:	bd80      	pop	{r7, pc}

08000568 <MX_DMA_Init>:
  */
void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 8000568:	4b0f      	ldr	r3, [pc, #60]	; (80005a8 <MX_DMA_Init+0x40>)

  /* DMA interrupt init */
  /* DMA2_Stream3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 0, 0);
 800056a:	2200      	movs	r2, #0
 800056c:	203b      	movs	r0, #59	; 0x3b
 800056e:	4611      	mov	r1, r2
{
 8000570:	b510      	push	{r4, lr}
  __HAL_RCC_DMA2_CLK_ENABLE();
 8000572:	6b1c      	ldr	r4, [r3, #48]	; 0x30
{
 8000574:	b082      	sub	sp, #8
  __HAL_RCC_DMA2_CLK_ENABLE();
 8000576:	f444 0480 	orr.w	r4, r4, #4194304	; 0x400000
 800057a:	631c      	str	r4, [r3, #48]	; 0x30
 800057c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800057e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8000582:	9301      	str	r3, [sp, #4]
 8000584:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 0, 0);
 8000586:	f000 fd6d 	bl	8001064 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
 800058a:	203b      	movs	r0, #59	; 0x3b
 800058c:	f000 fda4 	bl	80010d8 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream6_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, 0, 0);
 8000590:	2200      	movs	r2, #0
 8000592:	2045      	movs	r0, #69	; 0x45
 8000594:	4611      	mov	r1, r2
 8000596:	f000 fd65 	bl	8001064 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
 800059a:	2045      	movs	r0, #69	; 0x45

}
 800059c:	b002      	add	sp, #8
 800059e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
 80005a2:	f000 bd99 	b.w	80010d8 <HAL_NVIC_EnableIRQ>
 80005a6:	bf00      	nop
 80005a8:	40023800 	.word	0x40023800

080005ac <MX_GPIO_Init>:
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 80005ac:	4b47      	ldr	r3, [pc, #284]	; (80006cc <MX_GPIO_Init+0x120>)
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOI_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOK, GPIO_PIN_3, GPIO_PIN_SET);
 80005ae:	2201      	movs	r2, #1
 80005b0:	2108      	movs	r1, #8
{
 80005b2:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80005b4:	2400      	movs	r4, #0
{
 80005b6:	b091      	sub	sp, #68	; 0x44
  HAL_GPIO_WritePin(GPIOK, GPIO_PIN_3, GPIO_PIN_SET);
 80005b8:	4f45      	ldr	r7, [pc, #276]	; (80006d0 <MX_GPIO_Init+0x124>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80005ba:	940b      	str	r4, [sp, #44]	; 0x2c
 80005bc:	940a      	str	r4, [sp, #40]	; 0x28
 80005be:	940e      	str	r4, [sp, #56]	; 0x38

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOI, GPIO_PIN_1|GPIO_PIN_12, GPIO_PIN_SET);
 80005c0:	4e44      	ldr	r6, [pc, #272]	; (80006d4 <MX_GPIO_Init+0x128>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80005c2:	e9cd 440c 	strd	r4, r4, [sp, #48]	; 0x30
  __HAL_RCC_GPIOE_CLK_ENABLE();
 80005c6:	6b18      	ldr	r0, [r3, #48]	; 0x30
 80005c8:	f040 0010 	orr.w	r0, r0, #16
 80005cc:	6318      	str	r0, [r3, #48]	; 0x30
  HAL_GPIO_WritePin(GPIOK, GPIO_PIN_3, GPIO_PIN_SET);
 80005ce:	4638      	mov	r0, r7
  __HAL_RCC_GPIOE_CLK_ENABLE();
 80005d0:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 80005d2:	f005 0510 	and.w	r5, r5, #16
 80005d6:	9500      	str	r5, [sp, #0]
 80005d8:	9d00      	ldr	r5, [sp, #0]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80005da:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 80005dc:	f045 0504 	orr.w	r5, r5, #4
 80005e0:	631d      	str	r5, [r3, #48]	; 0x30
 80005e2:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 80005e4:	f005 0504 	and.w	r5, r5, #4
 80005e8:	9501      	str	r5, [sp, #4]
 80005ea:	9d01      	ldr	r5, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80005ec:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 80005ee:	4315      	orrs	r5, r2
 80005f0:	631d      	str	r5, [r3, #48]	; 0x30
 80005f2:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 80005f4:	4015      	ands	r5, r2
 80005f6:	9502      	str	r5, [sp, #8]
 80005f8:	9d02      	ldr	r5, [sp, #8]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 80005fa:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 80005fc:	f045 0540 	orr.w	r5, r5, #64	; 0x40
 8000600:	631d      	str	r5, [r3, #48]	; 0x30
 8000602:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 8000604:	f005 0540 	and.w	r5, r5, #64	; 0x40
 8000608:	9503      	str	r5, [sp, #12]
 800060a:	9d03      	ldr	r5, [sp, #12]
  __HAL_RCC_GPIOJ_CLK_ENABLE();
 800060c:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 800060e:	f445 7500 	orr.w	r5, r5, #512	; 0x200
 8000612:	631d      	str	r5, [r3, #48]	; 0x30
 8000614:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 8000616:	f405 7500 	and.w	r5, r5, #512	; 0x200
 800061a:	9504      	str	r5, [sp, #16]
 800061c:	9d04      	ldr	r5, [sp, #16]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800061e:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 8000620:	430d      	orrs	r5, r1
 8000622:	631d      	str	r5, [r3, #48]	; 0x30
 8000624:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 8000626:	400d      	ands	r5, r1
 8000628:	9505      	str	r5, [sp, #20]
 800062a:	9d05      	ldr	r5, [sp, #20]
  __HAL_RCC_GPIOK_CLK_ENABLE();
 800062c:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 800062e:	f445 6580 	orr.w	r5, r5, #1024	; 0x400
 8000632:	631d      	str	r5, [r3, #48]	; 0x30
 8000634:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 8000636:	f405 6580 	and.w	r5, r5, #1024	; 0x400
 800063a:	9506      	str	r5, [sp, #24]
 800063c:	9d06      	ldr	r5, [sp, #24]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 800063e:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 8000640:	f045 0520 	orr.w	r5, r5, #32
 8000644:	631d      	str	r5, [r3, #48]	; 0x30
 8000646:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 8000648:	f005 0520 	and.w	r5, r5, #32
 800064c:	9507      	str	r5, [sp, #28]
 800064e:	9d07      	ldr	r5, [sp, #28]
  __HAL_RCC_GPIOI_CLK_ENABLE();
 8000650:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 8000652:	f445 7580 	orr.w	r5, r5, #256	; 0x100
 8000656:	631d      	str	r5, [r3, #48]	; 0x30
 8000658:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 800065a:	f405 7580 	and.w	r5, r5, #256	; 0x100
 800065e:	9508      	str	r5, [sp, #32]
 8000660:	9d08      	ldr	r5, [sp, #32]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8000662:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 8000664:	f045 0580 	orr.w	r5, r5, #128	; 0x80
 8000668:	631d      	str	r5, [r3, #48]	; 0x30
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pin : PK3 */
  GPIO_InitStruct.Pin = GPIO_PIN_3;
 800066a:	2503      	movs	r5, #3
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800066c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800066e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000672:	9309      	str	r3, [sp, #36]	; 0x24
 8000674:	9b09      	ldr	r3, [sp, #36]	; 0x24
  HAL_GPIO_WritePin(GPIOK, GPIO_PIN_3, GPIO_PIN_SET);
 8000676:	f000 ff4d 	bl	8001514 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOI, GPIO_PIN_1|GPIO_PIN_12, GPIO_PIN_SET);
 800067a:	4630      	mov	r0, r6
 800067c:	2201      	movs	r2, #1
 800067e:	f241 0102 	movw	r1, #4098	; 0x1002
 8000682:	f000 ff47 	bl	8001514 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = GPIO_PIN_13;
 8000686:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800068a:	2300      	movs	r3, #0
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800068c:	a90a      	add	r1, sp, #40	; 0x28
 800068e:	4812      	ldr	r0, [pc, #72]	; (80006d8 <MX_GPIO_Init+0x12c>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000690:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pin = GPIO_PIN_3;
 8000692:	2400      	movs	r4, #0
  GPIO_InitStruct.Pin = GPIO_PIN_13;
 8000694:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000698:	f000 fe1c 	bl	80012d4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_3;
 800069c:	2208      	movs	r2, #8
 800069e:	2301      	movs	r3, #1
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
 80006a0:	4638      	mov	r0, r7
 80006a2:	a90a      	add	r1, sp, #40	; 0x28
  GPIO_InitStruct.Pin = GPIO_PIN_3;
 80006a4:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
 80006a8:	e9cd 450c 	strd	r4, r5, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
 80006ac:	f000 fe12 	bl	80012d4 <HAL_GPIO_Init>

  /*Configure GPIO pins : PI1 PI12 */
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_12;
 80006b0:	f241 0202 	movw	r2, #4098	; 0x1002
 80006b4:	2301      	movs	r3, #1
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 80006b6:	a90a      	add	r1, sp, #40	; 0x28
 80006b8:	4630      	mov	r0, r6
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_12;
 80006ba:	e9cd 450c 	strd	r4, r5, [sp, #48]	; 0x30
 80006be:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 80006c2:	f000 fe07 	bl	80012d4 <HAL_GPIO_Init>

}
 80006c6:	b011      	add	sp, #68	; 0x44
 80006c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80006ca:	bf00      	nop
 80006cc:	40023800 	.word	0x40023800
 80006d0:	40022800 	.word	0x40022800
 80006d4:	40022000 	.word	0x40022000
 80006d8:	40020800 	.word	0x40020800

080006dc <SCB_EnableICache>:
/**
  \brief   Enable I-Cache
  \details Turns on I-Cache
  */
__STATIC_INLINE void SCB_EnableICache (void)
{
 80006dc:	b480      	push	{r7}
 80006de:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80006e0:	f3bf 8f4f 	dsb	sy
}
 80006e4:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 80006e6:	f3bf 8f6f 	isb	sy
}
 80006ea:	bf00      	nop
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 80006ec:	4b0d      	ldr	r3, [pc, #52]	; (8000724 <SCB_EnableICache+0x48>)
 80006ee:	2200      	movs	r2, #0
 80006f0:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 80006f4:	f3bf 8f4f 	dsb	sy
}
 80006f8:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 80006fa:	f3bf 8f6f 	isb	sy
}
 80006fe:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 8000700:	4b08      	ldr	r3, [pc, #32]	; (8000724 <SCB_EnableICache+0x48>)
 8000702:	695b      	ldr	r3, [r3, #20]
 8000704:	4a07      	ldr	r2, [pc, #28]	; (8000724 <SCB_EnableICache+0x48>)
 8000706:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800070a:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 800070c:	f3bf 8f4f 	dsb	sy
}
 8000710:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000712:	f3bf 8f6f 	isb	sy
}
 8000716:	bf00      	nop
    __DSB();
    __ISB();
  #endif
}
 8000718:	bf00      	nop
 800071a:	46bd      	mov	sp, r7
 800071c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000720:	4770      	bx	lr
 8000722:	bf00      	nop
 8000724:	e000ed00 	.word	0xe000ed00

08000728 <SCB_EnableDCache>:
/**
  \brief   Enable D-Cache
  \details Turns on D-Cache
  */
__STATIC_INLINE void SCB_EnableDCache (void)
{
 8000728:	b480      	push	{r7}
 800072a:	b085      	sub	sp, #20
 800072c:	af00      	add	r7, sp, #0
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 800072e:	4b25      	ldr	r3, [pc, #148]	; (80007c4 <SCB_EnableDCache+0x9c>)
 8000730:	2200      	movs	r2, #0
 8000732:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 8000736:	f3bf 8f4f 	dsb	sy
}
 800073a:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
 800073c:	4b21      	ldr	r3, [pc, #132]	; (80007c4 <SCB_EnableDCache+0x9c>)
 800073e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8000742:	607b      	str	r3, [r7, #4]

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8000744:	687b      	ldr	r3, [r7, #4]
 8000746:	0b5b      	lsrs	r3, r3, #13
 8000748:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800074c:	60fb      	str	r3, [r7, #12]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 800074e:	687b      	ldr	r3, [r7, #4]
 8000750:	08db      	lsrs	r3, r3, #3
 8000752:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8000756:	60bb      	str	r3, [r7, #8]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000758:	68fb      	ldr	r3, [r7, #12]
 800075a:	015a      	lsls	r2, r3, #5
 800075c:	f643 73e0 	movw	r3, #16352	; 0x3fe0
 8000760:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
 8000762:	68ba      	ldr	r2, [r7, #8]
 8000764:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000766:	4917      	ldr	r1, [pc, #92]	; (80007c4 <SCB_EnableDCache+0x9c>)
 8000768:	4313      	orrs	r3, r2
 800076a:	f8c1 3260 	str.w	r3, [r1, #608]	; 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 800076e:	68bb      	ldr	r3, [r7, #8]
 8000770:	1e5a      	subs	r2, r3, #1
 8000772:	60ba      	str	r2, [r7, #8]
 8000774:	2b00      	cmp	r3, #0
 8000776:	bf14      	ite	ne
 8000778:	2301      	movne	r3, #1
 800077a:	2300      	moveq	r3, #0
 800077c:	b2db      	uxtb	r3, r3
 800077e:	2b00      	cmp	r3, #0
 8000780:	d000      	beq.n	8000784 <SCB_EnableDCache+0x5c>
      do {
 8000782:	e7e9      	b.n	8000758 <SCB_EnableDCache+0x30>
    } while(sets-- != 0U);
 8000784:	68fb      	ldr	r3, [r7, #12]
 8000786:	1e5a      	subs	r2, r3, #1
 8000788:	60fa      	str	r2, [r7, #12]
 800078a:	2b00      	cmp	r3, #0
 800078c:	bf14      	ite	ne
 800078e:	2301      	movne	r3, #1
 8000790:	2300      	moveq	r3, #0
 8000792:	b2db      	uxtb	r3, r3
 8000794:	2b00      	cmp	r3, #0
 8000796:	d000      	beq.n	800079a <SCB_EnableDCache+0x72>
    do {
 8000798:	e7d9      	b.n	800074e <SCB_EnableDCache+0x26>
  __ASM volatile ("dsb 0xF":::"memory");
 800079a:	f3bf 8f4f 	dsb	sy
}
 800079e:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 80007a0:	4b08      	ldr	r3, [pc, #32]	; (80007c4 <SCB_EnableDCache+0x9c>)
 80007a2:	695b      	ldr	r3, [r3, #20]
 80007a4:	4a07      	ldr	r2, [pc, #28]	; (80007c4 <SCB_EnableDCache+0x9c>)
 80007a6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80007aa:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 80007ac:	f3bf 8f4f 	dsb	sy
}
 80007b0:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 80007b2:	f3bf 8f6f 	isb	sy
}
 80007b6:	bf00      	nop

    __DSB();
    __ISB();
  #endif
}
 80007b8:	bf00      	nop
 80007ba:	3714      	adds	r7, #20
 80007bc:	46bd      	mov	sp, r7
 80007be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007c2:	4770      	bx	lr
 80007c4:	e000ed00 	.word	0xe000ed00

080007c8 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 80007c8:	b580      	push	{r7, lr}
 80007ca:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* Enable I-Cache---------------------------------------------------------*/
  SCB_EnableICache();
 80007cc:	f7ff ff86 	bl	80006dc <SCB_EnableICache>

  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();
 80007d0:	f7ff ffaa 	bl	8000728 <SCB_EnableDCache>

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80007d4:	f000 fc14 	bl	8001000 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 80007d8:	f000 f80a 	bl	80007f0 <_Z18SystemClock_Configv>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 80007dc:	f7ff fee6 	bl	80005ac <MX_GPIO_Init>
  MX_DMA_Init();
 80007e0:	f7ff fec2 	bl	8000568 <MX_DMA_Init>
  MX_TIM2_Init();
 80007e4:	f000 f96c 	bl	8000ac0 <MX_TIM2_Init>

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  lv_task_handler();
 80007e8:	f000 fb3a 	bl	8000e60 <lv_task_handler>
 80007ec:	e7fc      	b.n	80007e8 <main+0x20>
	...

080007f0 <_Z18SystemClock_Configv>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80007f0:	b580      	push	{r7, lr}
 80007f2:	b0b4      	sub	sp, #208	; 0xd0
 80007f4:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80007f6:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
 80007fa:	2230      	movs	r2, #48	; 0x30
 80007fc:	2100      	movs	r1, #0
 80007fe:	4618      	mov	r0, r3
 8000800:	f001 ff78 	bl	80026f4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000804:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 8000808:	2200      	movs	r2, #0
 800080a:	601a      	str	r2, [r3, #0]
 800080c:	605a      	str	r2, [r3, #4]
 800080e:	609a      	str	r2, [r3, #8]
 8000810:	60da      	str	r2, [r3, #12]
 8000812:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8000814:	f107 0308 	add.w	r3, r7, #8
 8000818:	2284      	movs	r2, #132	; 0x84
 800081a:	2100      	movs	r1, #0
 800081c:	4618      	mov	r0, r3
 800081e:	f001 ff69 	bl	80026f4 <memset>

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 8000822:	4b4d      	ldr	r3, [pc, #308]	; (8000958 <_Z18SystemClock_Configv+0x168>)
 8000824:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000826:	4a4c      	ldr	r2, [pc, #304]	; (8000958 <_Z18SystemClock_Configv+0x168>)
 8000828:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800082c:	6413      	str	r3, [r2, #64]	; 0x40
 800082e:	4b4a      	ldr	r3, [pc, #296]	; (8000958 <_Z18SystemClock_Configv+0x168>)
 8000830:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000832:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000836:	607b      	str	r3, [r7, #4]
 8000838:	687b      	ldr	r3, [r7, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800083a:	4b48      	ldr	r3, [pc, #288]	; (800095c <_Z18SystemClock_Configv+0x16c>)
 800083c:	681b      	ldr	r3, [r3, #0]
 800083e:	4a47      	ldr	r2, [pc, #284]	; (800095c <_Z18SystemClock_Configv+0x16c>)
 8000840:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8000844:	6013      	str	r3, [r2, #0]
 8000846:	4b45      	ldr	r3, [pc, #276]	; (800095c <_Z18SystemClock_Configv+0x16c>)
 8000848:	681b      	ldr	r3, [r3, #0]
 800084a:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800084e:	603b      	str	r3, [r7, #0]
 8000850:	683b      	ldr	r3, [r7, #0]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000852:	2301      	movs	r3, #1
 8000854:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000858:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800085c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000860:	2302      	movs	r3, #2
 8000862:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000866:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800086a:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  RCC_OscInitStruct.PLL.PLLM = 15;
 800086e:	230f      	movs	r3, #15
 8000870:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
  RCC_OscInitStruct.PLL.PLLN = 240;
 8000874:	23f0      	movs	r3, #240	; 0xf0
 8000876:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800087a:	2302      	movs	r3, #2
 800087c:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
  RCC_OscInitStruct.PLL.PLLQ = 9;
 8000880:	2309      	movs	r3, #9
 8000882:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000886:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
 800088a:	4618      	mov	r0, r3
 800088c:	f000 fe8a 	bl	80015a4 <HAL_RCC_OscConfig>
 8000890:	4603      	mov	r3, r0
 8000892:	2b00      	cmp	r3, #0
 8000894:	bf14      	ite	ne
 8000896:	2301      	movne	r3, #1
 8000898:	2300      	moveq	r3, #0
 800089a:	b2db      	uxtb	r3, r3
 800089c:	2b00      	cmp	r3, #0
 800089e:	d001      	beq.n	80008a4 <_Z18SystemClock_Configv+0xb4>
  {
    Error_Handler();
 80008a0:	f000 f874 	bl	800098c <Error_Handler>
  }
  /** Activate the Over-Drive mode
  */
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 80008a4:	f000 fe42 	bl	800152c <HAL_PWREx_EnableOverDrive>
 80008a8:	4603      	mov	r3, r0
 80008aa:	2b00      	cmp	r3, #0
 80008ac:	bf14      	ite	ne
 80008ae:	2301      	movne	r3, #1
 80008b0:	2300      	moveq	r3, #0
 80008b2:	b2db      	uxtb	r3, r3
 80008b4:	2b00      	cmp	r3, #0
 80008b6:	d001      	beq.n	80008bc <_Z18SystemClock_Configv+0xcc>
  {
    Error_Handler();
 80008b8:	f000 f868 	bl	800098c <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80008bc:	230f      	movs	r3, #15
 80008be:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80008c2:	2302      	movs	r3, #2
 80008c4:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80008c8:	2300      	movs	r3, #0
 80008ca:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80008ce:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 80008d2:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80008d6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80008da:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6) != HAL_OK)
 80008de:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 80008e2:	2106      	movs	r1, #6
 80008e4:	4618      	mov	r0, r3
 80008e6:	f001 f857 	bl	8001998 <HAL_RCC_ClockConfig>
 80008ea:	4603      	mov	r3, r0
 80008ec:	2b00      	cmp	r3, #0
 80008ee:	bf14      	ite	ne
 80008f0:	2301      	movne	r3, #1
 80008f2:	2300      	moveq	r3, #0
 80008f4:	b2db      	uxtb	r3, r3
 80008f6:	2b00      	cmp	r3, #0
 80008f8:	d001      	beq.n	80008fe <_Z18SystemClock_Configv+0x10e>
  {
    Error_Handler();
 80008fa:	f000 f847 	bl	800098c <Error_Handler>
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC|RCC_PERIPHCLK_I2C3
 80008fe:	4b18      	ldr	r3, [pc, #96]	; (8000960 <_Z18SystemClock_Configv+0x170>)
 8000900:	60bb      	str	r3, [r7, #8]
                              |RCC_PERIPHCLK_SDMMC1|RCC_PERIPHCLK_CLK48;
  PeriphClkInitStruct.PLLSAI.PLLSAIN = 114;
 8000902:	2372      	movs	r3, #114	; 0x72
 8000904:	61fb      	str	r3, [r7, #28]
  PeriphClkInitStruct.PLLSAI.PLLSAIR = 5;
 8000906:	2305      	movs	r3, #5
 8000908:	627b      	str	r3, [r7, #36]	; 0x24
  PeriphClkInitStruct.PLLSAI.PLLSAIQ = 2;
 800090a:	2302      	movs	r3, #2
 800090c:	623b      	str	r3, [r7, #32]
  PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV8;
 800090e:	2303      	movs	r3, #3
 8000910:	62bb      	str	r3, [r7, #40]	; 0x28
  PeriphClkInitStruct.PLLSAIDivQ = 1;
 8000912:	2301      	movs	r3, #1
 8000914:	633b      	str	r3, [r7, #48]	; 0x30
  PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_4;
 8000916:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800091a:	637b      	str	r3, [r7, #52]	; 0x34
  PeriphClkInitStruct.I2c3ClockSelection = RCC_I2C3CLKSOURCE_PCLK1;
 800091c:	2300      	movs	r3, #0
 800091e:	677b      	str	r3, [r7, #116]	; 0x74
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLLSAIP;
 8000920:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000924:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  PeriphClkInitStruct.Sdmmc1ClockSelection = RCC_SDMMC1CLKSOURCE_CLK48;
 8000928:	2300      	movs	r3, #0
 800092a:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800092e:	f107 0308 	add.w	r3, r7, #8
 8000932:	4618      	mov	r0, r3
 8000934:	f001 f950 	bl	8001bd8 <HAL_RCCEx_PeriphCLKConfig>
 8000938:	4603      	mov	r3, r0
 800093a:	2b00      	cmp	r3, #0
 800093c:	bf14      	ite	ne
 800093e:	2301      	movne	r3, #1
 8000940:	2300      	moveq	r3, #0
 8000942:	b2db      	uxtb	r3, r3
 8000944:	2b00      	cmp	r3, #0
 8000946:	d001      	beq.n	800094c <_Z18SystemClock_Configv+0x15c>
  {
    Error_Handler();
 8000948:	f000 f820 	bl	800098c <Error_Handler>
  }
  /** Enables the Clock Security System
  */
  HAL_RCC_EnableCSS();
 800094c:	f001 f8f8 	bl	8001b40 <HAL_RCC_EnableCSS>
}
 8000950:	bf00      	nop
 8000952:	37d0      	adds	r7, #208	; 0xd0
 8000954:	46bd      	mov	sp, r7
 8000956:	bd80      	pop	{r7, pc}
 8000958:	40023800 	.word	0x40023800
 800095c:	40007000 	.word	0x40007000
 8000960:	00a10008 	.word	0x00a10008

08000964 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8000964:	b580      	push	{r7, lr}
 8000966:	b082      	sub	sp, #8
 8000968:	af00      	add	r7, sp, #0
 800096a:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
 800096c:	687b      	ldr	r3, [r7, #4]
 800096e:	681b      	ldr	r3, [r3, #0]
 8000970:	4a05      	ldr	r2, [pc, #20]	; (8000988 <HAL_TIM_PeriodElapsedCallback+0x24>)
 8000972:	4293      	cmp	r3, r2
 8000974:	d104      	bne.n	8000980 <HAL_TIM_PeriodElapsedCallback+0x1c>
    HAL_IncTick();
 8000976:	f000 fb4f 	bl	8001018 <HAL_IncTick>
    lv_tick_inc(10);
 800097a:	200a      	movs	r0, #10
 800097c:	f000 f94e 	bl	8000c1c <lv_tick_inc>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 8000980:	bf00      	nop
 8000982:	3708      	adds	r7, #8
 8000984:	46bd      	mov	sp, r7
 8000986:	bd80      	pop	{r7, pc}
 8000988:	40010000 	.word	0x40010000

0800098c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800098c:	b480      	push	{r7}
 800098e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  while (1)
 8000990:	e7fe      	b.n	8000990 <Error_Handler+0x4>
	...

08000994 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 8000994:	4b0a      	ldr	r3, [pc, #40]	; (80009c0 <HAL_MspInit+0x2c>)
{
 8000996:	b082      	sub	sp, #8
  __HAL_RCC_PWR_CLK_ENABLE();
 8000998:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800099a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800099e:	641a      	str	r2, [r3, #64]	; 0x40
 80009a0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80009a2:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 80009a6:	9200      	str	r2, [sp, #0]
 80009a8:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80009aa:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80009ac:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80009b0:	645a      	str	r2, [r3, #68]	; 0x44
 80009b2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80009b4:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80009b8:	9301      	str	r3, [sp, #4]
 80009ba:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80009bc:	b002      	add	sp, #8
 80009be:	4770      	bx	lr
 80009c0:	40023800 	.word	0x40023800

080009c4 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80009c4:	b530      	push	{r4, r5, lr}
 80009c6:	4601      	mov	r1, r0
 80009c8:	b089      	sub	sp, #36	; 0x24
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  /*Configure the TIM1 IRQ priority */
  HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, TickPriority ,0);
 80009ca:	2200      	movs	r2, #0
 80009cc:	2019      	movs	r0, #25
 80009ce:	f000 fb49 	bl	8001064 <HAL_NVIC_SetPriority>

  /* Enable the TIM1 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn);
 80009d2:	2019      	movs	r0, #25
 80009d4:	f000 fb80 	bl	80010d8 <HAL_NVIC_EnableIRQ>
  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
 80009d8:	4b15      	ldr	r3, [pc, #84]	; (8000a30 <HAL_InitTick+0x6c>)

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 80009da:	a901      	add	r1, sp, #4
 80009dc:	a803      	add	r0, sp, #12
  __HAL_RCC_TIM1_CLK_ENABLE();
 80009de:	6c5a      	ldr	r2, [r3, #68]	; 0x44

  /* Compute TIM1 clock */
  uwTimclock = 2*HAL_RCC_GetPCLK2Freq();
  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 80009e0:	4d14      	ldr	r5, [pc, #80]	; (8000a34 <HAL_InitTick+0x70>)
  __HAL_RCC_TIM1_CLK_ENABLE();
 80009e2:	f042 0201 	orr.w	r2, r2, #1

  /* Initialize TIM1 */
  htim1.Instance = TIM1;
 80009e6:	4c14      	ldr	r4, [pc, #80]	; (8000a38 <HAL_InitTick+0x74>)
  __HAL_RCC_TIM1_CLK_ENABLE();
 80009e8:	645a      	str	r2, [r3, #68]	; 0x44
 80009ea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80009ec:	f003 0301 	and.w	r3, r3, #1
 80009f0:	9302      	str	r3, [sp, #8]
 80009f2:	9b02      	ldr	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 80009f4:	f001 f8bc 	bl	8001b70 <HAL_RCC_GetClockConfig>
  uwTimclock = 2*HAL_RCC_GetPCLK2Freq();
 80009f8:	f001 f8aa 	bl	8001b50 <HAL_RCC_GetPCLK2Freq>
  + Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim1.Init.Period = (1000000U / 1000U) - 1U;
 80009fc:	f240 32e7 	movw	r2, #999	; 0x3e7
  uwTimclock = 2*HAL_RCC_GetPCLK2Freq();
 8000a00:	0043      	lsls	r3, r0, #1
  htim1.Instance = TIM1;
 8000a02:	490e      	ldr	r1, [pc, #56]	; (8000a3c <HAL_InitTick+0x78>)
  htim1.Init.Period = (1000000U / 1000U) - 1U;
 8000a04:	60e2      	str	r2, [r4, #12]
  htim1.Init.Prescaler = uwPrescalerValue;
  htim1.Init.ClockDivision = 0;
 8000a06:	2200      	movs	r2, #0
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8000a08:	fba5 0303 	umull	r0, r3, r5, r3
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 8000a0c:	4620      	mov	r0, r4
  htim1.Instance = TIM1;
 8000a0e:	6021      	str	r1, [r4, #0]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8000a10:	0c9b      	lsrs	r3, r3, #18
  htim1.Init.ClockDivision = 0;
 8000a12:	6122      	str	r2, [r4, #16]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000a14:	60a2      	str	r2, [r4, #8]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8000a16:	3b01      	subs	r3, #1
  htim1.Init.Prescaler = uwPrescalerValue;
 8000a18:	6063      	str	r3, [r4, #4]
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 8000a1a:	f001 fb77 	bl	800210c <HAL_TIM_Base_Init>
 8000a1e:	b110      	cbz	r0, 8000a26 <HAL_InitTick+0x62>
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim1);
  }

  /* Return function status */
  return HAL_ERROR;
 8000a20:	2001      	movs	r0, #1
}
 8000a22:	b009      	add	sp, #36	; 0x24
 8000a24:	bd30      	pop	{r4, r5, pc}
    return HAL_TIM_Base_Start_IT(&htim1);
 8000a26:	4620      	mov	r0, r4
 8000a28:	f001 fc1c 	bl	8002264 <HAL_TIM_Base_Start_IT>
}
 8000a2c:	b009      	add	sp, #36	; 0x24
 8000a2e:	bd30      	pop	{r4, r5, pc}
 8000a30:	40023800 	.word	0x40023800
 8000a34:	431bde83 	.word	0x431bde83
 8000a38:	20000364 	.word	0x20000364
 8000a3c:	40010000 	.word	0x40010000

08000a40 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8000a40:	b508      	push	{r3, lr}
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  HAL_RCC_NMI_IRQHandler();
 8000a42:	f001 f8b9 	bl	8001bb8 <HAL_RCC_NMI_IRQHandler>
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8000a46:	e7fe      	b.n	8000a46 <NMI_Handler+0x6>

08000a48 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8000a48:	e7fe      	b.n	8000a48 <HardFault_Handler>
 8000a4a:	bf00      	nop

08000a4c <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8000a4c:	e7fe      	b.n	8000a4c <MemManage_Handler>
 8000a4e:	bf00      	nop

08000a50 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8000a50:	e7fe      	b.n	8000a50 <BusFault_Handler>
 8000a52:	bf00      	nop

08000a54 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8000a54:	e7fe      	b.n	8000a54 <UsageFault_Handler>
 8000a56:	bf00      	nop

08000a58 <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8000a58:	4770      	bx	lr
 8000a5a:	bf00      	nop

08000a5c <DebugMon_Handler>:
 8000a5c:	4770      	bx	lr
 8000a5e:	bf00      	nop

08000a60 <PendSV_Handler>:
 8000a60:	4770      	bx	lr
 8000a62:	bf00      	nop

08000a64 <SysTick_Handler>:
 8000a64:	4770      	bx	lr
 8000a66:	bf00      	nop

08000a68 <TIM1_UP_TIM10_IRQHandler>:
void TIM1_UP_TIM10_IRQHandler(void)
{
  /* USER CODE BEGIN TIM1_UP_TIM10_IRQn 0 */

  /* USER CODE END TIM1_UP_TIM10_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 8000a68:	4801      	ldr	r0, [pc, #4]	; (8000a70 <TIM1_UP_TIM10_IRQHandler+0x8>)
 8000a6a:	f001 bd05 	b.w	8002478 <HAL_TIM_IRQHandler>
 8000a6e:	bf00      	nop
 8000a70:	20000364 	.word	0x20000364

08000a74 <TIM2_IRQHandler>:
void TIM2_IRQHandler(void)
{
  /* USER CODE BEGIN TIM2_IRQn 0 */

  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&htim2);
 8000a74:	4801      	ldr	r0, [pc, #4]	; (8000a7c <TIM2_IRQHandler+0x8>)
 8000a76:	f001 bcff 	b.w	8002478 <HAL_TIM_IRQHandler>
 8000a7a:	bf00      	nop
 8000a7c:	200003b0 	.word	0x200003b0

08000a80 <DMA2_Stream3_IRQHandler>:
void DMA2_Stream3_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream3_IRQn 0 */

  /* USER CODE END DMA2_Stream3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sdmmc1_rx);
 8000a80:	4801      	ldr	r0, [pc, #4]	; (8000a88 <DMA2_Stream3_IRQHandler+0x8>)
 8000a82:	f000 bb37 	b.w	80010f4 <HAL_DMA_IRQHandler>
 8000a86:	bf00      	nop
 8000a88:	200002a4 	.word	0x200002a4

08000a8c <DMA2_Stream6_IRQHandler>:
void DMA2_Stream6_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream6_IRQn 0 */

  /* USER CODE END DMA2_Stream6_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sdmmc1_tx);
 8000a8c:	4801      	ldr	r0, [pc, #4]	; (8000a94 <DMA2_Stream6_IRQHandler+0x8>)
 8000a8e:	f000 bb31 	b.w	80010f4 <HAL_DMA_IRQHandler>
 8000a92:	bf00      	nop
 8000a94:	20000304 	.word	0x20000304

08000a98 <I2C3_EV_IRQHandler>:
void I2C3_EV_IRQHandler(void)
{
  /* USER CODE BEGIN I2C3_EV_IRQn 0 */

  /* USER CODE END I2C3_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c3);
 8000a98:	4801      	ldr	r0, [pc, #4]	; (8000aa0 <I2C3_EV_IRQHandler+0x8>)
 8000a9a:	f000 bd3f 	b.w	800151c <HAL_I2C_EV_IRQHandler>
 8000a9e:	bf00      	nop
 8000aa0:	200001d4 	.word	0x200001d4

08000aa4 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000aa4:	4b05      	ldr	r3, [pc, #20]	; (8000abc <SystemInit+0x18>)

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = RAMDTCM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000aa6:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000aaa:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8000aae:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8000ab2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000ab6:	6099      	str	r1, [r3, #8]
#endif
}
 8000ab8:	4770      	bx	lr
 8000aba:	bf00      	nop
 8000abc:	e000ed00 	.word	0xe000ed00

08000ac0 <MX_TIM2_Init>:

TIM_HandleTypeDef htim2;

/* TIM2 init function */
void MX_TIM2_Init(void)
{
 8000ac0:	b510      	push	{r4, lr}
  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 10000;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000ac2:	2300      	movs	r3, #0
{
 8000ac4:	b088      	sub	sp, #32
  htim2.Instance = TIM2;
 8000ac6:	4818      	ldr	r0, [pc, #96]	; (8000b28 <MX_TIM2_Init+0x68>)
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000ac8:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8000acc:	f242 7210 	movw	r2, #10000	; 0x2710
 8000ad0:	2464      	movs	r4, #100	; 0x64
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8000ad2:	9304      	str	r3, [sp, #16]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8000ad4:	9301      	str	r3, [sp, #4]
  htim2.Init.Period = 100;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8000ad6:	6103      	str	r3, [r0, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8000ad8:	6183      	str	r3, [r0, #24]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8000ada:	9307      	str	r3, [sp, #28]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000adc:	e880 001e 	stmia.w	r0, {r1, r2, r3, r4}
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8000ae0:	e9cd 3305 	strd	r3, r3, [sp, #20]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8000ae4:	e9cd 3302 	strd	r3, r3, [sp, #8]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 8000ae8:	f001 fb10 	bl	800210c <HAL_TIM_Base_Init>
 8000aec:	b990      	cbnz	r0, 8000b14 <MX_TIM2_Init+0x54>
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8000aee:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 8000af2:	a904      	add	r1, sp, #16
 8000af4:	480c      	ldr	r0, [pc, #48]	; (8000b28 <MX_TIM2_Init+0x68>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8000af6:	9304      	str	r3, [sp, #16]
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 8000af8:	f001 fc10 	bl	800231c <HAL_TIM_ConfigClockSource>
 8000afc:	b988      	cbnz	r0, 8000b22 <MX_TIM2_Init+0x62>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 8000afe:	2220      	movs	r2, #32
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8000b00:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8000b02:	a901      	add	r1, sp, #4
 8000b04:	4808      	ldr	r0, [pc, #32]	; (8000b28 <MX_TIM2_Init+0x68>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 8000b06:	9201      	str	r2, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8000b08:	9303      	str	r3, [sp, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8000b0a:	f001 fd6d 	bl	80025e8 <HAL_TIMEx_MasterConfigSynchronization>
 8000b0e:	b920      	cbnz	r0, 8000b1a <MX_TIM2_Init+0x5a>
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}
 8000b10:	b008      	add	sp, #32
 8000b12:	bd10      	pop	{r4, pc}
    Error_Handler();
 8000b14:	f7ff ff3a 	bl	800098c <Error_Handler>
 8000b18:	e7e9      	b.n	8000aee <MX_TIM2_Init+0x2e>
    Error_Handler();
 8000b1a:	f7ff ff37 	bl	800098c <Error_Handler>
}
 8000b1e:	b008      	add	sp, #32
 8000b20:	bd10      	pop	{r4, pc}
    Error_Handler();
 8000b22:	f7ff ff33 	bl	800098c <Error_Handler>
 8000b26:	e7ea      	b.n	8000afe <MX_TIM2_Init+0x3e>
 8000b28:	200003b0 	.word	0x200003b0

08000b2c <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{

  if(tim_baseHandle->Instance==TIM2)
 8000b2c:	6803      	ldr	r3, [r0, #0]
 8000b2e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8000b32:	d000      	beq.n	8000b36 <HAL_TIM_Base_MspInit+0xa>
 8000b34:	4770      	bx	lr
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* TIM2 clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 8000b36:	f503 330e 	add.w	r3, r3, #145408	; 0x23800

    /* TIM2 interrupt Init */
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
 8000b3a:	2200      	movs	r2, #0
 8000b3c:	201c      	movs	r0, #28
 8000b3e:	4611      	mov	r1, r2
{
 8000b40:	b510      	push	{r4, lr}
    __HAL_RCC_TIM2_CLK_ENABLE();
 8000b42:	6c1c      	ldr	r4, [r3, #64]	; 0x40
{
 8000b44:	b082      	sub	sp, #8
    __HAL_RCC_TIM2_CLK_ENABLE();
 8000b46:	f044 0401 	orr.w	r4, r4, #1
 8000b4a:	641c      	str	r4, [r3, #64]	; 0x40
 8000b4c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000b4e:	f003 0301 	and.w	r3, r3, #1
 8000b52:	9301      	str	r3, [sp, #4]
 8000b54:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
 8000b56:	f000 fa85 	bl	8001064 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
 8000b5a:	201c      	movs	r0, #28
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
}
 8000b5c:	b002      	add	sp, #8
 8000b5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
 8000b62:	f000 bab9 	b.w	80010d8 <HAL_NVIC_EnableIRQ>
 8000b66:	bf00      	nop

08000b68 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8000b68:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000ba0 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8000b6c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8000b6e:	e003      	b.n	8000b78 <LoopCopyDataInit>

08000b70 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8000b70:	4b0c      	ldr	r3, [pc, #48]	; (8000ba4 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8000b72:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8000b74:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8000b76:	3104      	adds	r1, #4

08000b78 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8000b78:	480b      	ldr	r0, [pc, #44]	; (8000ba8 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8000b7a:	4b0c      	ldr	r3, [pc, #48]	; (8000bac <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8000b7c:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8000b7e:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8000b80:	d3f6      	bcc.n	8000b70 <CopyDataInit>
  ldr  r2, =_sbss
 8000b82:	4a0b      	ldr	r2, [pc, #44]	; (8000bb0 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8000b84:	e002      	b.n	8000b8c <LoopFillZerobss>

08000b86 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8000b86:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8000b88:	f842 3b04 	str.w	r3, [r2], #4

08000b8c <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8000b8c:	4b09      	ldr	r3, [pc, #36]	; (8000bb4 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8000b8e:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8000b90:	d3f9      	bcc.n	8000b86 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 8000b92:	f7ff ff87 	bl	8000aa4 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8000b96:	f001 fd89 	bl	80026ac <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8000b9a:	f7ff fe15 	bl	80007c8 <main>
  bx  lr    
 8000b9e:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8000ba0:	20050000 	.word	0x20050000
  ldr  r3, =_sidata
 8000ba4:	0800274c 	.word	0x0800274c
  ldr  r0, =_sdata
 8000ba8:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8000bac:	2000000c 	.word	0x2000000c
  ldr  r2, =_sbss
 8000bb0:	2000000c 	.word	0x2000000c
  ldr  r3, = _ebss
 8000bb4:	20000588 	.word	0x20000588

08000bb8 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000bb8:	e7fe      	b.n	8000bb8 <ADC_IRQHandler>

08000bba <_ZN20displayer_gui_driverC1Ev>:
#include "sdram.hpp"

class displayer_gui_driver: public ::displayer, ::sdram_handler
{
public:
	displayer_gui_driver() = default;
 8000bba:	b580      	push	{r7, lr}
 8000bbc:	b082      	sub	sp, #8
 8000bbe:	af00      	add	r7, sp, #0
 8000bc0:	6078      	str	r0, [r7, #4]
 8000bc2:	687b      	ldr	r3, [r7, #4]
 8000bc4:	4618      	mov	r0, r3
 8000bc6:	f7ff fc9b 	bl	8000500 <_ZN9displayerC1Ev>
 8000bca:	687b      	ldr	r3, [r7, #4]
 8000bcc:	33a8      	adds	r3, #168	; 0xa8
 8000bce:	4618      	mov	r0, r3
 8000bd0:	f7ff fca1 	bl	8000516 <_ZN13sdram_handlerC1Ev>
 8000bd4:	687b      	ldr	r3, [r7, #4]
 8000bd6:	4618      	mov	r0, r3
 8000bd8:	3708      	adds	r7, #8
 8000bda:	46bd      	mov	sp, r7
 8000bdc:	bd80      	pop	{r7, pc}
	...

08000be0 <_Z41__static_initialization_and_destruction_0ii>:

void application::app_run()
{


}
 8000be0:	b580      	push	{r7, lr}
 8000be2:	b082      	sub	sp, #8
 8000be4:	af00      	add	r7, sp, #0
 8000be6:	6078      	str	r0, [r7, #4]
 8000be8:	6039      	str	r1, [r7, #0]
 8000bea:	687b      	ldr	r3, [r7, #4]
 8000bec:	2b01      	cmp	r3, #1
 8000bee:	d107      	bne.n	8000c00 <_Z41__static_initialization_and_destruction_0ii+0x20>
 8000bf0:	683b      	ldr	r3, [r7, #0]
 8000bf2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000bf6:	4293      	cmp	r3, r2
 8000bf8:	d102      	bne.n	8000c00 <_Z41__static_initialization_and_destruction_0ii+0x20>
static displayer_gui_driver gui;
 8000bfa:	4803      	ldr	r0, [pc, #12]	; (8000c08 <_Z41__static_initialization_and_destruction_0ii+0x28>)
 8000bfc:	f7ff ffdd 	bl	8000bba <_ZN20displayer_gui_driverC1Ev>
}
 8000c00:	bf00      	nop
 8000c02:	3708      	adds	r7, #8
 8000c04:	46bd      	mov	sp, r7
 8000c06:	bd80      	pop	{r7, pc}
 8000c08:	200000d0 	.word	0x200000d0

08000c0c <_GLOBAL__sub_I__ZN11application8app_initEv>:
 8000c0c:	b580      	push	{r7, lr}
 8000c0e:	af00      	add	r7, sp, #0
 8000c10:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8000c14:	2001      	movs	r0, #1
 8000c16:	f7ff ffe3 	bl	8000be0 <_Z41__static_initialization_and_destruction_0ii>
 8000c1a:	bd80      	pop	{r7, pc}

08000c1c <lv_tick_inc>:
 * @param tick_period the call period of this function in milliseconds
 */
LV_ATTRIBUTE_TICK_INC void lv_tick_inc(uint32_t tick_period)
{
    tick_irq_flag = 0;
    sys_time += tick_period;
 8000c1c:	4a05      	ldr	r2, [pc, #20]	; (8000c34 <lv_tick_inc+0x18>)
    tick_irq_flag = 0;
 8000c1e:	4906      	ldr	r1, [pc, #24]	; (8000c38 <lv_tick_inc+0x1c>)
    sys_time += tick_period;
 8000c20:	6813      	ldr	r3, [r2, #0]
{
 8000c22:	b410      	push	{r4}
    tick_irq_flag = 0;
 8000c24:	2400      	movs	r4, #0
    sys_time += tick_period;
 8000c26:	4418      	add	r0, r3
    tick_irq_flag = 0;
 8000c28:	700c      	strb	r4, [r1, #0]
}
 8000c2a:	f85d 4b04 	ldr.w	r4, [sp], #4
    sys_time += tick_period;
 8000c2e:	6010      	str	r0, [r2, #0]
}
 8000c30:	4770      	bx	lr
 8000c32:	bf00      	nop
 8000c34:	200001b0 	.word	0x200001b0
 8000c38:	200001b4 	.word	0x200001b4

08000c3c <lv_tick_get>:
     * If `tick_irq_flag` was cleared in `lv_tick_inc` try to read again
     * until `tick_irq_flag` remains `1`. */
    uint32_t result;
    do {
        tick_irq_flag = 1;
        result        = sys_time;
 8000c3c:	4a04      	ldr	r2, [pc, #16]	; (8000c50 <lv_tick_get+0x14>)
        tick_irq_flag = 1;
 8000c3e:	2101      	movs	r1, #1
 8000c40:	4b04      	ldr	r3, [pc, #16]	; (8000c54 <lv_tick_get+0x18>)
        result        = sys_time;
 8000c42:	6810      	ldr	r0, [r2, #0]
        tick_irq_flag = 1;
 8000c44:	7019      	strb	r1, [r3, #0]
    } while(!tick_irq_flag); /*Continue until see a non interrupted cycle */
 8000c46:	781a      	ldrb	r2, [r3, #0]
 8000c48:	2a00      	cmp	r2, #0
 8000c4a:	d0fb      	beq.n	8000c44 <lv_tick_get+0x8>

    return result;
#else
    return LV_TICK_CUSTOM_SYS_TIME_EXPR;
#endif
}
 8000c4c:	4770      	bx	lr
 8000c4e:	bf00      	nop
 8000c50:	200001b0 	.word	0x200001b0
 8000c54:	200001b4 	.word	0x200001b4

08000c58 <lv_tick_elaps>:
        result        = sys_time;
 8000c58:	4a06      	ldr	r2, [pc, #24]	; (8000c74 <lv_tick_elaps+0x1c>)
        tick_irq_flag = 1;
 8000c5a:	2101      	movs	r1, #1
 8000c5c:	4b06      	ldr	r3, [pc, #24]	; (8000c78 <lv_tick_elaps+0x20>)
 * Get the elapsed milliseconds since a previous time stamp
 * @param prev_tick a previous time stamp (return value of lv_tick_get() )
 * @return the elapsed milliseconds since 'prev_tick'
 */
uint32_t lv_tick_elaps(uint32_t prev_tick)
{
 8000c5e:	b410      	push	{r4}
        result        = sys_time;
 8000c60:	6814      	ldr	r4, [r2, #0]
        tick_irq_flag = 1;
 8000c62:	7019      	strb	r1, [r3, #0]
    } while(!tick_irq_flag); /*Continue until see a non interrupted cycle */
 8000c64:	781a      	ldrb	r2, [r3, #0]
 8000c66:	2a00      	cmp	r2, #0
 8000c68:	d0fb      	beq.n	8000c62 <lv_tick_elaps+0xa>
        prev_tick = UINT32_MAX - prev_tick + 1;
        prev_tick += act_time;
    }

    return prev_tick;
}
 8000c6a:	1a20      	subs	r0, r4, r0
 8000c6c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000c70:	4770      	bx	lr
 8000c72:	bf00      	nop
 8000c74:	200001b0 	.word	0x200001b0
 8000c78:	200001b4 	.word	0x200001b4

08000c7c <_lv_ll_remove>:
 */
void * _lv_ll_get_head(const lv_ll_t * ll_p)
{
    void * head = NULL;

    if(ll_p != NULL) {
 8000c7c:	b308      	cbz	r0, 8000cc2 <_lv_ll_remove+0x46>
    if(_lv_ll_get_head(ll_p) == node_p) {
 8000c7e:	6843      	ldr	r3, [r0, #4]
 8000c80:	4299      	cmp	r1, r3
 8000c82:	d00e      	beq.n	8000ca2 <_lv_ll_remove+0x26>
    else if(_lv_ll_get_tail(ll_p) == node_p) {
 8000c84:	6883      	ldr	r3, [r0, #8]
 8000c86:	4299      	cmp	r1, r3
 8000c88:	d013      	beq.n	8000cb2 <_lv_ll_remove+0x36>
    if(ll_p == NULL) return NULL;

    /* Pointer to the prev. node is stored in the end of this node.
     * Go there and return the address found there */
    const lv_ll_node_t * n_act_d = n_act;
    n_act_d += LL_PREV_P_OFFSET(ll_p);
 8000c8a:	6803      	ldr	r3, [r0, #0]
{
 8000c8c:	b410      	push	{r4}
    return *((lv_ll_node_t **)n_act_d);
 8000c8e:	58c8      	ldr	r0, [r1, r3]
    n_act_d += LL_NEXT_P_OFFSET(ll_p);
 8000c90:	1d1c      	adds	r4, r3, #4
    return *((lv_ll_node_t **)n_act_d);
 8000c92:	590a      	ldr	r2, [r1, r4]
 * @param act pointer to a node which next node pointer should be set
 * @param next pointer to a node which should be the next node before 'act'
 */
static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)
{
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
 8000c94:	b100      	cbz	r0, 8000c98 <_lv_ll_remove+0x1c>

    act8 += LL_NEXT_P_OFFSET(ll_p);
    lv_ll_node_t ** act_node_p = (lv_ll_node_t **) act8;
    lv_ll_node_t ** next_node_p = (lv_ll_node_t **) &next;

    *act_node_p = *next_node_p;
 8000c96:	5102      	str	r2, [r0, r4]
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
 8000c98:	b102      	cbz	r2, 8000c9c <_lv_ll_remove+0x20>
    *act_node_p = *prev_node_p;
 8000c9a:	50d0      	str	r0, [r2, r3]
}
 8000c9c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000ca0:	4770      	bx	lr
    n_act_d += LL_NEXT_P_OFFSET(ll_p);
 8000ca2:	6802      	ldr	r2, [r0, #0]
    return *((lv_ll_node_t **)n_act_d);
 8000ca4:	4411      	add	r1, r2
 8000ca6:	684b      	ldr	r3, [r1, #4]
        ll_p->head = _lv_ll_get_next(ll_p, node_p);
 8000ca8:	6043      	str	r3, [r0, #4]
        if(ll_p->head == NULL) {
 8000caa:	b163      	cbz	r3, 8000cc6 <_lv_ll_remove+0x4a>
    *act_node_p = *prev_node_p;
 8000cac:	2100      	movs	r1, #0
 8000cae:	5099      	str	r1, [r3, r2]
 8000cb0:	4770      	bx	lr
    n_act_d += LL_PREV_P_OFFSET(ll_p);
 8000cb2:	6802      	ldr	r2, [r0, #0]
    return *((lv_ll_node_t **)n_act_d);
 8000cb4:	588b      	ldr	r3, [r1, r2]
        ll_p->tail = _lv_ll_get_prev(ll_p, node_p);
 8000cb6:	6083      	str	r3, [r0, #8]
        if(ll_p->tail == NULL) {
 8000cb8:	b13b      	cbz	r3, 8000cca <_lv_ll_remove+0x4e>
    *act_node_p = *next_node_p;
 8000cba:	4413      	add	r3, r2
 8000cbc:	2200      	movs	r2, #0
 8000cbe:	605a      	str	r2, [r3, #4]
 8000cc0:	4770      	bx	lr
    if(_lv_ll_get_head(ll_p) == node_p) {
 8000cc2:	b121      	cbz	r1, 8000cce <_lv_ll_remove+0x52>
 8000cc4:	4770      	bx	lr
            ll_p->tail = NULL;
 8000cc6:	6083      	str	r3, [r0, #8]
 8000cc8:	4770      	bx	lr
            ll_p->head = NULL;
 8000cca:	6043      	str	r3, [r0, #4]
 8000ccc:	4770      	bx	lr
        ll_p->head = _lv_ll_get_next(ll_p, node_p);
 8000cce:	6049      	str	r1, [r1, #4]
 8000cd0:	deff      	udf	#255	; 0xff
 8000cd2:	bf00      	nop

08000cd4 <_lv_ll_get_head>:
    if(ll_p != NULL) {
 8000cd4:	b100      	cbz	r0, 8000cd8 <_lv_ll_get_head+0x4>
        head = ll_p->head;
 8000cd6:	6840      	ldr	r0, [r0, #4]
}
 8000cd8:	4770      	bx	lr
 8000cda:	bf00      	nop

08000cdc <_lv_ll_get_next>:
    if(ll_p == NULL) return NULL;
 8000cdc:	b110      	cbz	r0, 8000ce4 <_lv_ll_get_next+0x8>
    return *((lv_ll_node_t **)n_act_d);
 8000cde:	6803      	ldr	r3, [r0, #0]
 8000ce0:	4419      	add	r1, r3
 8000ce2:	6848      	ldr	r0, [r1, #4]
}
 8000ce4:	4770      	bx	lr
 8000ce6:	bf00      	nop

08000ce8 <lv_mem_defrag>:
static lv_mem_ent_t * ent_get_next(lv_mem_ent_t * act_e)
{
    lv_mem_ent_t * next_e = NULL;

    if(act_e == NULL) { /*NULL means: get the first entry*/
        next_e = (lv_mem_ent_t *)work_mem;
 8000ce8:	4b1d      	ldr	r3, [pc, #116]	; (8000d60 <lv_mem_defrag+0x78>)
 8000cea:	6818      	ldr	r0, [r3, #0]
        while(e_free != NULL) {
 8000cec:	2800      	cmp	r0, #0
 8000cee:	d036      	beq.n	8000d5e <lv_mem_defrag+0x76>
 8000cf0:	4601      	mov	r1, r0
{
 8000cf2:	b470      	push	{r4, r5, r6}
 8000cf4:	f811 4b04 	ldrb.w	r4, [r1], #4
 8000cf8:	f500 4600 	add.w	r6, r0, #32768	; 0x8000
 8000cfc:	f004 0501 	and.w	r5, r4, #1
            if(e_free->header.s.used != 0) {
 8000d00:	b155      	cbz	r5, 8000d18 <lv_mem_defrag+0x30>
    }
    else {   /*Get the next entry */
        uint8_t * data = &act_e->first_data;
        next_e         = (lv_mem_ent_t *)&data[act_e->header.s.d_size];
 8000d02:	6800      	ldr	r0, [r0, #0]
 8000d04:	eb01 0050 	add.w	r0, r1, r0, lsr #1

        if(&next_e->first_data >= &work_mem[LV_MEM_SIZE]) next_e = NULL;
 8000d08:	1d01      	adds	r1, r0, #4
 8000d0a:	42b1      	cmp	r1, r6
 8000d0c:	d223      	bcs.n	8000d56 <lv_mem_defrag+0x6e>
 8000d0e:	7804      	ldrb	r4, [r0, #0]
 8000d10:	f004 0501 	and.w	r5, r4, #1
            if(e_free->header.s.used != 0) {
 8000d14:	2d00      	cmp	r5, #0
 8000d16:	d1f4      	bne.n	8000d02 <lv_mem_defrag+0x1a>
        next_e         = (lv_mem_ent_t *)&data[act_e->header.s.d_size];
 8000d18:	6802      	ldr	r2, [r0, #0]
 8000d1a:	eb01 0352 	add.w	r3, r1, r2, lsr #1
 8000d1e:	f3c2 025e 	ubfx	r2, r2, #1, #31
        if(&next_e->first_data >= &work_mem[LV_MEM_SIZE]) next_e = NULL;
 8000d22:	1d19      	adds	r1, r3, #4
 8000d24:	42b1      	cmp	r1, r6
 8000d26:	d216      	bcs.n	8000d56 <lv_mem_defrag+0x6e>
            if(e_next->header.s.used == 0) {
 8000d28:	781c      	ldrb	r4, [r3, #0]
                e_free->header.s.d_size += e_next->header.s.d_size + sizeof(e_next->header);
 8000d2a:	3204      	adds	r2, #4
            if(e_next->header.s.used == 0) {
 8000d2c:	f004 0501 	and.w	r5, r4, #1
 8000d30:	07e4      	lsls	r4, r4, #31
 8000d32:	d412      	bmi.n	8000d5a <lv_mem_defrag+0x72>
                e_free->header.s.d_size += e_next->header.s.d_size + sizeof(e_next->header);
 8000d34:	681d      	ldr	r5, [r3, #0]
 8000d36:	6804      	ldr	r4, [r0, #0]
 8000d38:	eb02 0255 	add.w	r2, r2, r5, lsr #1
 8000d3c:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8000d40:	f362 045f 	bfi	r4, r2, #1, #31
 8000d44:	6004      	str	r4, [r0, #0]
        next_e         = (lv_mem_ent_t *)&data[act_e->header.s.d_size];
 8000d46:	681b      	ldr	r3, [r3, #0]
 8000d48:	eb01 0353 	add.w	r3, r1, r3, lsr #1
        if(&next_e->first_data >= &work_mem[LV_MEM_SIZE]) next_e = NULL;
 8000d4c:	1d19      	adds	r1, r3, #4
 8000d4e:	42b1      	cmp	r1, r6
 8000d50:	d201      	bcs.n	8000d56 <lv_mem_defrag+0x6e>
        while(e_next != NULL) {
 8000d52:	2b00      	cmp	r3, #0
 8000d54:	d1e8      	bne.n	8000d28 <lv_mem_defrag+0x40>
}
 8000d56:	bc70      	pop	{r4, r5, r6}
 8000d58:	4770      	bx	lr
 8000d5a:	4618      	mov	r0, r3
        while(e_free != NULL) {
 8000d5c:	e7d0      	b.n	8000d00 <lv_mem_defrag+0x18>
 8000d5e:	4770      	bx	lr
 8000d60:	200001b8 	.word	0x200001b8

08000d64 <lv_mem_free>:
    if(data == NULL) return;
 8000d64:	2800      	cmp	r0, #0
 8000d66:	d03e      	beq.n	8000de6 <lv_mem_free+0x82>
    if(data == &zero_mem) return;
 8000d68:	4a1f      	ldr	r2, [pc, #124]	; (8000de8 <lv_mem_free+0x84>)
    if(data == NULL) return;
 8000d6a:	1a82      	subs	r2, r0, r2
 8000d6c:	fab2 f282 	clz	r2, r2
 8000d70:	0952      	lsrs	r2, r2, #5
 8000d72:	2a00      	cmp	r2, #0
 8000d74:	d137      	bne.n	8000de6 <lv_mem_free+0x82>
    full_defrag_cnt++;
 8000d76:	491d      	ldr	r1, [pc, #116]	; (8000dec <lv_mem_free+0x88>)
 8000d78:	880b      	ldrh	r3, [r1, #0]
 8000d7a:	3301      	adds	r3, #1
{
 8000d7c:	b470      	push	{r4, r5, r6}
    full_defrag_cnt++;
 8000d7e:	b29b      	uxth	r3, r3
    e->header.s.used = 0;
 8000d80:	f810 4c04 	ldrb.w	r4, [r0, #-4]
    if(full_defrag_cnt < LV_MEM_FULL_DEFRAG_CNT) {
 8000d84:	2b0f      	cmp	r3, #15
    e->header.s.used = 0;
 8000d86:	f362 0400 	bfi	r4, r2, #0, #1
    full_defrag_cnt++;
 8000d8a:	800b      	strh	r3, [r1, #0]
    e->header.s.used = 0;
 8000d8c:	f800 4c04 	strb.w	r4, [r0, #-4]
    if(full_defrag_cnt < LV_MEM_FULL_DEFRAG_CNT) {
 8000d90:	d825      	bhi.n	8000dde <lv_mem_free+0x7a>
        next_e         = (lv_mem_ent_t *)&data[act_e->header.s.d_size];
 8000d92:	f850 2c04 	ldr.w	r2, [r0, #-4]
        if(&next_e->first_data >= &work_mem[LV_MEM_SIZE]) next_e = NULL;
 8000d96:	4916      	ldr	r1, [pc, #88]	; (8000df0 <lv_mem_free+0x8c>)
        next_e         = (lv_mem_ent_t *)&data[act_e->header.s.d_size];
 8000d98:	eb00 0352 	add.w	r3, r0, r2, lsr #1
 8000d9c:	f3c2 025e 	ubfx	r2, r2, #1, #31
        if(&next_e->first_data >= &work_mem[LV_MEM_SIZE]) next_e = NULL;
 8000da0:	680d      	ldr	r5, [r1, #0]
 8000da2:	1d19      	adds	r1, r3, #4
 8000da4:	f505 4500 	add.w	r5, r5, #32768	; 0x8000
 8000da8:	42a9      	cmp	r1, r5
 8000daa:	d216      	bcs.n	8000dda <lv_mem_free+0x76>
            if(e_next->header.s.used == 0) {
 8000dac:	781c      	ldrb	r4, [r3, #0]
                e->header.s.d_size += e_next->header.s.d_size + sizeof(e->header);
 8000dae:	3204      	adds	r2, #4
            if(e_next->header.s.used == 0) {
 8000db0:	07e4      	lsls	r4, r4, #31
 8000db2:	d412      	bmi.n	8000dda <lv_mem_free+0x76>
                e->header.s.d_size += e_next->header.s.d_size + sizeof(e->header);
 8000db4:	681e      	ldr	r6, [r3, #0]
 8000db6:	f850 4c04 	ldr.w	r4, [r0, #-4]
 8000dba:	eb02 0256 	add.w	r2, r2, r6, lsr #1
 8000dbe:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8000dc2:	f362 045f 	bfi	r4, r2, #1, #31
 8000dc6:	f840 4c04 	str.w	r4, [r0, #-4]
        next_e         = (lv_mem_ent_t *)&data[act_e->header.s.d_size];
 8000dca:	681b      	ldr	r3, [r3, #0]
 8000dcc:	eb01 0353 	add.w	r3, r1, r3, lsr #1
        if(&next_e->first_data >= &work_mem[LV_MEM_SIZE]) next_e = NULL;
 8000dd0:	1d19      	adds	r1, r3, #4
 8000dd2:	428d      	cmp	r5, r1
 8000dd4:	d901      	bls.n	8000dda <lv_mem_free+0x76>
        while(e_next != NULL) {
 8000dd6:	2b00      	cmp	r3, #0
 8000dd8:	d1e8      	bne.n	8000dac <lv_mem_free+0x48>
}
 8000dda:	bc70      	pop	{r4, r5, r6}
 8000ddc:	4770      	bx	lr
 8000dde:	bc70      	pop	{r4, r5, r6}
        full_defrag_cnt = 0;
 8000de0:	800a      	strh	r2, [r1, #0]
        lv_mem_defrag();
 8000de2:	f7ff bf81 	b.w	8000ce8 <lv_mem_defrag>
 8000de6:	4770      	bx	lr
 8000de8:	200001bc 	.word	0x200001bc
 8000dec:	200001b6 	.word	0x200001b6
 8000df0:	200001b8 	.word	0x200001b8

08000df4 <lv_task_exec>:
 * Execute task if its the priority is appropriate
 * @param task pointer to lv_task
 * @return true: execute, false: not executed
 */
static bool lv_task_exec(lv_task_t * task)
{
 8000df4:	b570      	push	{r4, r5, r6, lr}
 8000df6:	4604      	mov	r4, r0
 * @return the time remaining, or 0 if it needs to be run again
 */
static uint32_t lv_task_time_remaining(lv_task_t * task)
{
    /*Check if at least 'period' time elapsed*/
    uint32_t elp = lv_tick_elaps(task->last_run);
 8000df8:	6840      	ldr	r0, [r0, #4]
 8000dfa:	f7ff ff2d 	bl	8000c58 <lv_tick_elaps>
    if(elp >= task->period)
 8000dfe:	6823      	ldr	r3, [r4, #0]
 8000e00:	4298      	cmp	r0, r3
 8000e02:	d201      	bcs.n	8000e08 <lv_task_exec+0x14>
    bool exec = false;
 8000e04:	2000      	movs	r0, #0
}
 8000e06:	bd70      	pop	{r4, r5, r6, pc}
        task->last_run = lv_tick_get();
 8000e08:	f7ff ff18 	bl	8000c3c <lv_tick_get>
        if(task->task_cb) task->task_cb(task);
 8000e0c:	68a3      	ldr	r3, [r4, #8]
        task->last_run = lv_tick_get();
 8000e0e:	6060      	str	r0, [r4, #4]
        if(task->task_cb) task->task_cb(task);
 8000e10:	b10b      	cbz	r3, 8000e16 <lv_task_exec+0x22>
 8000e12:	4620      	mov	r0, r4
 8000e14:	4798      	blx	r3
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
 8000e16:	4e0e      	ldr	r6, [pc, #56]	; (8000e50 <lv_task_exec+0x5c>)
 8000e18:	7833      	ldrb	r3, [r6, #0]
 8000e1a:	b99b      	cbnz	r3, 8000e44 <lv_task_exec+0x50>
            if(task->repeat_count > 0) {
 8000e1c:	6923      	ldr	r3, [r4, #16]
 8000e1e:	2b00      	cmp	r3, #0
 8000e20:	dd01      	ble.n	8000e26 <lv_task_exec+0x32>
                task->repeat_count--;
 8000e22:	3b01      	subs	r3, #1
 8000e24:	6123      	str	r3, [r4, #16]
            if(task->repeat_count == 0) {
 8000e26:	b96b      	cbnz	r3, 8000e44 <lv_task_exec+0x50>
    _lv_ll_remove(&LV_GC_ROOT(_lv_task_ll), task);
 8000e28:	4621      	mov	r1, r4
 8000e2a:	480a      	ldr	r0, [pc, #40]	; (8000e54 <lv_task_exec+0x60>)
 8000e2c:	f7ff ff26 	bl	8000c7c <_lv_ll_remove>
    task_list_changed = true;
 8000e30:	2501      	movs	r5, #1
 8000e32:	4b09      	ldr	r3, [pc, #36]	; (8000e58 <lv_task_exec+0x64>)
    lv_mem_free(task);
 8000e34:	4620      	mov	r0, r4
    task_list_changed = true;
 8000e36:	701d      	strb	r5, [r3, #0]
    lv_mem_free(task);
 8000e38:	f7ff ff94 	bl	8000d64 <lv_mem_free>
    if(LV_GC_ROOT(_lv_task_act) == task) task_deleted = true; /*The active task was deleted*/
 8000e3c:	4b07      	ldr	r3, [pc, #28]	; (8000e5c <lv_task_exec+0x68>)
 8000e3e:	681b      	ldr	r3, [r3, #0]
 8000e40:	429c      	cmp	r4, r3
 8000e42:	d001      	beq.n	8000e48 <lv_task_exec+0x54>
        exec = true;
 8000e44:	2001      	movs	r0, #1
}
 8000e46:	bd70      	pop	{r4, r5, r6, pc}
    if(LV_GC_ROOT(_lv_task_act) == task) task_deleted = true; /*The active task was deleted*/
 8000e48:	4628      	mov	r0, r5
 8000e4a:	7035      	strb	r5, [r6, #0]
}
 8000e4c:	bd70      	pop	{r4, r5, r6, pc}
 8000e4e:	bf00      	nop
 8000e50:	200001d2 	.word	0x200001d2
 8000e54:	200003fc 	.word	0x200003fc
 8000e58:	200001d3 	.word	0x200001d3
 8000e5c:	200004cc 	.word	0x200004cc

08000e60 <lv_task_handler>:
{
 8000e60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(already_running) return 1;
 8000e64:	f8df b18c 	ldr.w	fp, [pc, #396]	; 8000ff4 <lv_task_handler+0x194>
 8000e68:	f89b 4000 	ldrb.w	r4, [fp]
{
 8000e6c:	ed2d 8b02 	vpush	{d8}
 8000e70:	b083      	sub	sp, #12
    if(already_running) return 1;
 8000e72:	2c00      	cmp	r4, #0
 8000e74:	f040 80a5 	bne.w	8000fc2 <lv_task_handler+0x162>
    if(lv_task_run == false) {
 8000e78:	4b57      	ldr	r3, [pc, #348]	; (8000fd8 <lv_task_handler+0x178>)
    already_running = true;
 8000e7a:	2501      	movs	r5, #1
    if(lv_task_run == false) {
 8000e7c:	781b      	ldrb	r3, [r3, #0]
    already_running = true;
 8000e7e:	f88b 5000 	strb.w	r5, [fp]
    if(lv_task_run == false) {
 8000e82:	b93b      	cbnz	r3, 8000e94 <lv_task_handler+0x34>
}
 8000e84:	4628      	mov	r0, r5
    already_running = false; /*Release the mutex*/
 8000e86:	f88b 3000 	strb.w	r3, [fp]
}
 8000e8a:	b003      	add	sp, #12
 8000e8c:	ecbd 8b02 	vpop	{d8}
 8000e90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint32_t handler_start = lv_tick_get();
 8000e94:	f7ff fed2 	bl	8000c3c <lv_tick_get>
 8000e98:	f8df 815c 	ldr.w	r8, [pc, #348]	; 8000ff8 <lv_task_handler+0x198>
        task_deleted             = false;
 8000e9c:	46a2      	mov	sl, r4
 8000e9e:	4f4f      	ldr	r7, [pc, #316]	; (8000fdc <lv_task_handler+0x17c>)
    uint32_t handler_start = lv_tick_get();
 8000ea0:	ee08 0a10 	vmov	s16, r0
    lv_task_t * task_interrupter = NULL;
 8000ea4:	f8df 9154 	ldr.w	r9, [pc, #340]	; 8000ffc <lv_task_handler+0x19c>
 8000ea8:	4d4d      	ldr	r5, [pc, #308]	; (8000fe0 <lv_task_handler+0x180>)
        LV_GC_ROOT(_lv_task_act) = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
 8000eaa:	4e4e      	ldr	r6, [pc, #312]	; (8000fe4 <lv_task_handler+0x184>)
 8000eac:	4630      	mov	r0, r6
        task_deleted             = false;
 8000eae:	f888 a000 	strb.w	sl, [r8]
        task_created             = false;
 8000eb2:	f887 a000 	strb.w	sl, [r7]
        task_list_changed        = false;
 8000eb6:	f889 a000 	strb.w	sl, [r9]
        LV_GC_ROOT(_lv_task_act) = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
 8000eba:	f7ff ff0b 	bl	8000cd4 <_lv_ll_get_head>
 8000ebe:	4601      	mov	r1, r0
 8000ec0:	6029      	str	r1, [r5, #0]
        while(LV_GC_ROOT(_lv_task_act)) {
 8000ec2:	b361      	cbz	r1, 8000f1e <lv_task_handler+0xbe>
            next = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), LV_GC_ROOT(_lv_task_act));
 8000ec4:	4630      	mov	r0, r6
 8000ec6:	f7ff ff09 	bl	8000cdc <_lv_ll_get_next>
            if(LV_GC_ROOT(_lv_task_act)->prio == LV_TASK_PRIO_OFF) {
 8000eca:	682a      	ldr	r2, [r5, #0]
            next = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), LV_GC_ROOT(_lv_task_act));
 8000ecc:	4601      	mov	r1, r0
            if(LV_GC_ROOT(_lv_task_act)->prio == LV_TASK_PRIO_OFF) {
 8000ece:	7d13      	ldrb	r3, [r2, #20]
 8000ed0:	f013 0007 	ands.w	r0, r3, #7
 8000ed4:	d023      	beq.n	8000f1e <lv_task_handler+0xbe>
            if(LV_GC_ROOT(_lv_task_act) == task_interrupter) {
 8000ed6:	42a2      	cmp	r2, r4
 8000ed8:	d06a      	beq.n	8000fb0 <lv_task_handler+0x150>
            if(LV_GC_ROOT(_lv_task_act)->prio == LV_TASK_PRIO_HIGHEST) {
 8000eda:	2805      	cmp	r0, #5
 8000edc:	d06b      	beq.n	8000fb6 <lv_task_handler+0x156>
            else if(task_interrupter) {
 8000ede:	b18c      	cbz	r4, 8000f04 <lv_task_handler+0xa4>
                if(LV_GC_ROOT(_lv_task_act)->prio > task_interrupter->prio) {
 8000ee0:	7d20      	ldrb	r0, [r4, #20]
 8000ee2:	f003 0307 	and.w	r3, r3, #7
 8000ee6:	f000 0007 	and.w	r0, r0, #7
 8000eea:	4283      	cmp	r3, r0
 8000eec:	d80a      	bhi.n	8000f04 <lv_task_handler+0xa4>
            if(task_created || task_deleted) {
 8000eee:	783b      	ldrb	r3, [r7, #0]
 8000ef0:	b9ab      	cbnz	r3, 8000f1e <lv_task_handler+0xbe>
 8000ef2:	f898 3000 	ldrb.w	r3, [r8]
 8000ef6:	b993      	cbnz	r3, 8000f1e <lv_task_handler+0xbe>
            if(task_list_changed) {
 8000ef8:	f899 2000 	ldrb.w	r2, [r9]
 8000efc:	2a00      	cmp	r2, #0
 8000efe:	d0df      	beq.n	8000ec0 <lv_task_handler+0x60>
                task_interrupter = NULL;
 8000f00:	461c      	mov	r4, r3
 8000f02:	e7d3      	b.n	8000eac <lv_task_handler+0x4c>
                if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
 8000f04:	4610      	mov	r0, r2
 8000f06:	9101      	str	r1, [sp, #4]
 8000f08:	f7ff ff74 	bl	8000df4 <lv_task_exec>
 8000f0c:	9901      	ldr	r1, [sp, #4]
 8000f0e:	2800      	cmp	r0, #0
 8000f10:	d0ed      	beq.n	8000eee <lv_task_handler+0x8e>
                    if(!task_created && !task_deleted) {
 8000f12:	783b      	ldrb	r3, [r7, #0]
 8000f14:	b91b      	cbnz	r3, 8000f1e <lv_task_handler+0xbe>
 8000f16:	f898 3000 	ldrb.w	r3, [r8]
 8000f1a:	2b00      	cmp	r3, #0
 8000f1c:	d05a      	beq.n	8000fd4 <lv_task_handler+0x174>
    next = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
 8000f1e:	4831      	ldr	r0, [pc, #196]	; (8000fe4 <lv_task_handler+0x184>)
    uint32_t time_till_next = LV_NO_TASK_READY;
 8000f20:	f04f 35ff 	mov.w	r5, #4294967295
    next = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
 8000f24:	f7ff fed6 	bl	8000cd4 <_lv_ll_get_head>
    while(next && next->prio != LV_TASK_PRIO_OFF) {
 8000f28:	4604      	mov	r4, r0
 8000f2a:	b1e8      	cbz	r0, 8000f68 <lv_task_handler+0x108>
        next = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), next); /*Find the next task*/
 8000f2c:	4e2d      	ldr	r6, [pc, #180]	; (8000fe4 <lv_task_handler+0x184>)
 8000f2e:	e008      	b.n	8000f42 <lv_task_handler+0xe2>
 8000f30:	4285      	cmp	r5, r0
 8000f32:	4621      	mov	r1, r4
 8000f34:	bf28      	it	cs
 8000f36:	4605      	movcs	r5, r0
 8000f38:	4630      	mov	r0, r6
 8000f3a:	f7ff fecf 	bl	8000cdc <_lv_ll_get_next>
    while(next && next->prio != LV_TASK_PRIO_OFF) {
 8000f3e:	4604      	mov	r4, r0
 8000f40:	b190      	cbz	r0, 8000f68 <lv_task_handler+0x108>
 8000f42:	7d23      	ldrb	r3, [r4, #20]
 8000f44:	075b      	lsls	r3, r3, #29
 8000f46:	d00f      	beq.n	8000f68 <lv_task_handler+0x108>
    uint32_t elp = lv_tick_elaps(task->last_run);
 8000f48:	6860      	ldr	r0, [r4, #4]
 8000f4a:	f7ff fe85 	bl	8000c58 <lv_tick_elaps>
    if(elp >= task->period)
 8000f4e:	6823      	ldr	r3, [r4, #0]
 8000f50:	4298      	cmp	r0, r3
        return 0;
    return task->period - elp;
 8000f52:	eba3 0000 	sub.w	r0, r3, r0
    if(elp >= task->period)
 8000f56:	d3eb      	bcc.n	8000f30 <lv_task_handler+0xd0>
        next = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), next); /*Find the next task*/
 8000f58:	4621      	mov	r1, r4
 8000f5a:	4630      	mov	r0, r6
 8000f5c:	f7ff febe 	bl	8000cdc <_lv_ll_get_next>
 8000f60:	2500      	movs	r5, #0
    while(next && next->prio != LV_TASK_PRIO_OFF) {
 8000f62:	4604      	mov	r4, r0
 8000f64:	2800      	cmp	r0, #0
 8000f66:	d1ec      	bne.n	8000f42 <lv_task_handler+0xe2>
    busy_time += lv_tick_elaps(handler_start);
 8000f68:	4e1f      	ldr	r6, [pc, #124]	; (8000fe8 <lv_task_handler+0x188>)
 8000f6a:	ee18 0a10 	vmov	r0, s16
 8000f6e:	f7ff fe73 	bl	8000c58 <lv_tick_elaps>
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
 8000f72:	4c1e      	ldr	r4, [pc, #120]	; (8000fec <lv_task_handler+0x18c>)
    busy_time += lv_tick_elaps(handler_start);
 8000f74:	6833      	ldr	r3, [r6, #0]
 8000f76:	4403      	add	r3, r0
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
 8000f78:	6820      	ldr	r0, [r4, #0]
    busy_time += lv_tick_elaps(handler_start);
 8000f7a:	6033      	str	r3, [r6, #0]
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
 8000f7c:	f7ff fe6c 	bl	8000c58 <lv_tick_elaps>
    if(idle_period_time >= IDLE_MEAS_PERIOD) {
 8000f80:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 8000f84:	d312      	bcc.n	8000fac <lv_task_handler+0x14c>
        idle_last         = (busy_time * 100) / idle_period_time;  /*Calculate the busy percentage*/
 8000f86:	6833      	ldr	r3, [r6, #0]
 8000f88:	2264      	movs	r2, #100	; 0x64
 8000f8a:	fb02 f203 	mul.w	r2, r2, r3
 8000f8e:	fbb2 f3f0 	udiv	r3, r2, r0
 8000f92:	b2db      	uxtb	r3, r3
        idle_last         = idle_last > 100 ? 0 : 100 - idle_last; /*But we need idle time*/
 8000f94:	2b64      	cmp	r3, #100	; 0x64
 8000f96:	d81b      	bhi.n	8000fd0 <lv_task_handler+0x170>
 8000f98:	f1c3 0364 	rsb	r3, r3, #100	; 0x64
 8000f9c:	b2db      	uxtb	r3, r3
 8000f9e:	4914      	ldr	r1, [pc, #80]	; (8000ff0 <lv_task_handler+0x190>)
        busy_time         = 0;
 8000fa0:	2200      	movs	r2, #0
        idle_last         = idle_last > 100 ? 0 : 100 - idle_last; /*But we need idle time*/
 8000fa2:	700b      	strb	r3, [r1, #0]
        busy_time         = 0;
 8000fa4:	6032      	str	r2, [r6, #0]
        idle_period_start = lv_tick_get();
 8000fa6:	f7ff fe49 	bl	8000c3c <lv_tick_get>
 8000faa:	6020      	str	r0, [r4, #0]
    already_running = false; /*Release the mutex*/
 8000fac:	2300      	movs	r3, #0
 8000fae:	e769      	b.n	8000e84 <lv_task_handler+0x24>
                task_interrupter = NULL; /*From this point only task after the interrupter comes, so
 8000fb0:	2400      	movs	r4, #0
                LV_GC_ROOT(_lv_task_act) = next;
 8000fb2:	6029      	str	r1, [r5, #0]
                continue; /*Load the next task*/
 8000fb4:	e785      	b.n	8000ec2 <lv_task_handler+0x62>
                lv_task_exec(LV_GC_ROOT(_lv_task_act));
 8000fb6:	4610      	mov	r0, r2
 8000fb8:	9101      	str	r1, [sp, #4]
 8000fba:	f7ff ff1b 	bl	8000df4 <lv_task_exec>
 8000fbe:	9901      	ldr	r1, [sp, #4]
 8000fc0:	e795      	b.n	8000eee <lv_task_handler+0x8e>
    if(already_running) return 1;
 8000fc2:	2501      	movs	r5, #1
}
 8000fc4:	4628      	mov	r0, r5
 8000fc6:	b003      	add	sp, #12
 8000fc8:	ecbd 8b02 	vpop	{d8}
 8000fcc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        idle_last         = idle_last > 100 ? 0 : 100 - idle_last; /*But we need idle time*/
 8000fd0:	2300      	movs	r3, #0
 8000fd2:	e7e4      	b.n	8000f9e <lv_task_handler+0x13e>
                        task_interrupter = LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
 8000fd4:	682c      	ldr	r4, [r5, #0]
    } while(!end_flag);
 8000fd6:	e769      	b.n	8000eac <lv_task_handler+0x4c>
 8000fd8:	200001d0 	.word	0x200001d0
 8000fdc:	200001d1 	.word	0x200001d1
 8000fe0:	200004cc 	.word	0x200004cc
 8000fe4:	200003fc 	.word	0x200003fc
 8000fe8:	200001c4 	.word	0x200001c4
 8000fec:	200001cc 	.word	0x200001cc
 8000ff0:	200001c8 	.word	0x200001c8
 8000ff4:	200001c0 	.word	0x200001c0
 8000ff8:	200001d2 	.word	0x200001d2
 8000ffc:	200001d3 	.word	0x200001d3

08001000 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001000:	b508      	push	{r3, lr}
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001002:	2003      	movs	r0, #3
 8001004:	f000 f81a 	bl	800103c <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8001008:	2000      	movs	r0, #0
 800100a:	f7ff fcdb 	bl	80009c4 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 800100e:	f7ff fcc1 	bl	8000994 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 8001012:	2000      	movs	r0, #0
 8001014:	bd08      	pop	{r3, pc}
 8001016:	bf00      	nop

08001018 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8001018:	4a03      	ldr	r2, [pc, #12]	; (8001028 <HAL_IncTick+0x10>)
 800101a:	4b04      	ldr	r3, [pc, #16]	; (800102c <HAL_IncTick+0x14>)
 800101c:	6811      	ldr	r1, [r2, #0]
 800101e:	781b      	ldrb	r3, [r3, #0]
 8001020:	440b      	add	r3, r1
 8001022:	6013      	str	r3, [r2, #0]
}
 8001024:	4770      	bx	lr
 8001026:	bf00      	nop
 8001028:	20000584 	.word	0x20000584
 800102c:	20000004 	.word	0x20000004

08001030 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8001030:	4b01      	ldr	r3, [pc, #4]	; (8001038 <HAL_GetTick+0x8>)
 8001032:	6818      	ldr	r0, [r3, #0]
}
 8001034:	4770      	bx	lr
 8001036:	bf00      	nop
 8001038:	20000584 	.word	0x20000584

0800103c <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800103c:	4907      	ldr	r1, [pc, #28]	; (800105c <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800103e:	0200      	lsls	r0, r0, #8
  reg_value  =  (reg_value                                   |
 8001040:	4b07      	ldr	r3, [pc, #28]	; (8001060 <HAL_NVIC_SetPriorityGrouping+0x24>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001042:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001044:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001048:	b410      	push	{r4}
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800104a:	f64f 04ff 	movw	r4, #63743	; 0xf8ff
 800104e:	4022      	ands	r2, r4
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8001050:	f85d 4b04 	ldr.w	r4, [sp], #4
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001054:	4310      	orrs	r0, r2
  reg_value  =  (reg_value                                   |
 8001056:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8001058:	60cb      	str	r3, [r1, #12]
 800105a:	4770      	bx	lr
 800105c:	e000ed00 	.word	0xe000ed00
 8001060:	05fa0000 	.word	0x05fa0000

08001064 <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001064:	4b19      	ldr	r3, [pc, #100]	; (80010cc <HAL_NVIC_SetPriority+0x68>)
 8001066:	68db      	ldr	r3, [r3, #12]
 8001068:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800106c:	b430      	push	{r4, r5}
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800106e:	f1c3 0507 	rsb	r5, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001072:	1d1c      	adds	r4, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001074:	2d04      	cmp	r5, #4
 8001076:	bf28      	it	cs
 8001078:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800107a:	2c06      	cmp	r4, #6
 800107c:	d919      	bls.n	80010b2 <HAL_NVIC_SetPriority+0x4e>
 800107e:	3b03      	subs	r3, #3
 8001080:	f04f 34ff 	mov.w	r4, #4294967295
 8001084:	409c      	lsls	r4, r3
 8001086:	ea22 0204 	bic.w	r2, r2, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800108a:	f04f 34ff 	mov.w	r4, #4294967295
  if ((int32_t)(IRQn) >= 0)
 800108e:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001090:	fa04 f405 	lsl.w	r4, r4, r5
 8001094:	ea21 0104 	bic.w	r1, r1, r4
 8001098:	fa01 f103 	lsl.w	r1, r1, r3
 800109c:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) >= 0)
 80010a0:	db0a      	blt.n	80010b8 <HAL_NVIC_SetPriority+0x54>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80010a2:	0109      	lsls	r1, r1, #4
 80010a4:	4b0a      	ldr	r3, [pc, #40]	; (80010d0 <HAL_NVIC_SetPriority+0x6c>)
 80010a6:	b2c9      	uxtb	r1, r1
 80010a8:	4403      	add	r3, r0
 80010aa:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80010ae:	bc30      	pop	{r4, r5}
 80010b0:	4770      	bx	lr
 80010b2:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80010b4:	4613      	mov	r3, r2
 80010b6:	e7e8      	b.n	800108a <HAL_NVIC_SetPriority+0x26>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80010b8:	f000 000f 	and.w	r0, r0, #15
 80010bc:	0109      	lsls	r1, r1, #4
 80010be:	4b05      	ldr	r3, [pc, #20]	; (80010d4 <HAL_NVIC_SetPriority+0x70>)
 80010c0:	b2c9      	uxtb	r1, r1
 80010c2:	4403      	add	r3, r0
 80010c4:	7619      	strb	r1, [r3, #24]
 80010c6:	bc30      	pop	{r4, r5}
 80010c8:	4770      	bx	lr
 80010ca:	bf00      	nop
 80010cc:	e000ed00 	.word	0xe000ed00
 80010d0:	e000e100 	.word	0xe000e100
 80010d4:	e000ecfc 	.word	0xe000ecfc

080010d8 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80010d8:	2800      	cmp	r0, #0
 80010da:	db07      	blt.n	80010ec <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80010dc:	f000 011f 	and.w	r1, r0, #31
 80010e0:	2301      	movs	r3, #1
 80010e2:	0940      	lsrs	r0, r0, #5
 80010e4:	4a02      	ldr	r2, [pc, #8]	; (80010f0 <HAL_NVIC_EnableIRQ+0x18>)
 80010e6:	408b      	lsls	r3, r1
 80010e8:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80010ec:	4770      	bx	lr
 80010ee:	bf00      	nop
 80010f0:	e000e100 	.word	0xe000e100

080010f4 <HAL_DMA_IRQHandler>:
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  uint32_t tmpisr;
  __IO uint32_t count = 0;
  uint32_t timeout = SystemCoreClock / 9600;
 80010f4:	4b75      	ldr	r3, [pc, #468]	; (80012cc <HAL_DMA_IRQHandler+0x1d8>)
  __IO uint32_t count = 0;
 80010f6:	2100      	movs	r1, #0
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;

  tmpisr = regs->ISR;

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 80010f8:	2208      	movs	r2, #8
{
 80010fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t timeout = SystemCoreClock / 9600;
 80010fe:	681d      	ldr	r5, [r3, #0]
{
 8001100:	b082      	sub	sp, #8
 8001102:	4680      	mov	r8, r0
  __IO uint32_t count = 0;
 8001104:	9101      	str	r1, [sp, #4]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8001106:	e9d0 6316 	ldrd	r6, r3, [r0, #88]	; 0x58
  tmpisr = regs->ISR;
 800110a:	6834      	ldr	r4, [r6, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 800110c:	409a      	lsls	r2, r3
 800110e:	4222      	tst	r2, r4
 8001110:	d004      	beq.n	800111c <HAL_DMA_IRQHandler+0x28>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8001112:	6801      	ldr	r1, [r0, #0]
 8001114:	680f      	ldr	r7, [r1, #0]
 8001116:	0778      	lsls	r0, r7, #29
 8001118:	f100 808a 	bmi.w	8001230 <HAL_DMA_IRQHandler+0x13c>
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 800111c:	2201      	movs	r2, #1
 800111e:	409a      	lsls	r2, r3
 8001120:	4222      	tst	r2, r4
 8001122:	d004      	beq.n	800112e <HAL_DMA_IRQHandler+0x3a>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8001124:	f8d8 1000 	ldr.w	r1, [r8]
 8001128:	6949      	ldr	r1, [r1, #20]
 800112a:	0609      	lsls	r1, r1, #24
 800112c:	d478      	bmi.n	8001220 <HAL_DMA_IRQHandler+0x12c>
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 800112e:	2204      	movs	r2, #4
 8001130:	409a      	lsls	r2, r3
 8001132:	4222      	tst	r2, r4
 8001134:	d004      	beq.n	8001140 <HAL_DMA_IRQHandler+0x4c>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8001136:	f8d8 1000 	ldr.w	r1, [r8]
 800113a:	6809      	ldr	r1, [r1, #0]
 800113c:	078f      	lsls	r7, r1, #30
 800113e:	d467      	bmi.n	8001210 <HAL_DMA_IRQHandler+0x11c>
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8001140:	2210      	movs	r2, #16
 8001142:	409a      	lsls	r2, r3
 8001144:	4222      	tst	r2, r4
 8001146:	d004      	beq.n	8001152 <HAL_DMA_IRQHandler+0x5e>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8001148:	f8d8 1000 	ldr.w	r1, [r8]
 800114c:	680f      	ldr	r7, [r1, #0]
 800114e:	0738      	lsls	r0, r7, #28
 8001150:	d449      	bmi.n	80011e6 <HAL_DMA_IRQHandler+0xf2>
        }
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8001152:	2220      	movs	r2, #32
 8001154:	409a      	lsls	r2, r3
 8001156:	4222      	tst	r2, r4
 8001158:	d017      	beq.n	800118a <HAL_DMA_IRQHandler+0x96>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 800115a:	f8d8 1000 	ldr.w	r1, [r8]
 800115e:	680c      	ldr	r4, [r1, #0]
 8001160:	06e0      	lsls	r0, r4, #27
 8001162:	d512      	bpl.n	800118a <HAL_DMA_IRQHandler+0x96>
    {
      /* Clear the transfer complete flag */
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8001164:	60b2      	str	r2, [r6, #8]
      
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8001166:	f898 2035 	ldrb.w	r2, [r8, #53]	; 0x35
 800116a:	2a05      	cmp	r2, #5
 800116c:	d073      	beq.n	8001256 <HAL_DMA_IRQHandler+0x162>
          hdma->XferAbortCallback(hdma);
        }
        return;
      }

      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 800116e:	680b      	ldr	r3, [r1, #0]
 8001170:	f413 2f80 	tst.w	r3, #262144	; 0x40000
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8001174:	680b      	ldr	r3, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8001176:	f000 8090 	beq.w	800129a <HAL_DMA_IRQHandler+0x1a6>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 800117a:	0319      	lsls	r1, r3, #12
 800117c:	f140 809b 	bpl.w	80012b6 <HAL_DMA_IRQHandler+0x1c2>

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
        }

        if(hdma->XferCpltCallback != NULL)
 8001180:	f8d8 303c 	ldr.w	r3, [r8, #60]	; 0x3c
 8001184:	b10b      	cbz	r3, 800118a <HAL_DMA_IRQHandler+0x96>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 8001186:	4640      	mov	r0, r8
 8001188:	4798      	blx	r3
      }
    }
  }
  
  /* manage error case */
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 800118a:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 800118e:	b33b      	cbz	r3, 80011e0 <HAL_DMA_IRQHandler+0xec>
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 8001190:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 8001194:	07da      	lsls	r2, r3, #31
 8001196:	d51b      	bpl.n	80011d0 <HAL_DMA_IRQHandler+0xdc>
    {
      hdma->State = HAL_DMA_STATE_ABORT;

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
 8001198:	f8d8 2000 	ldr.w	r2, [r8]
      hdma->State = HAL_DMA_STATE_ABORT;
 800119c:	2105      	movs	r1, #5
  uint32_t timeout = SystemCoreClock / 9600;
 800119e:	4b4c      	ldr	r3, [pc, #304]	; (80012d0 <HAL_DMA_IRQHandler+0x1dc>)
      hdma->State = HAL_DMA_STATE_ABORT;
 80011a0:	f888 1035 	strb.w	r1, [r8, #53]	; 0x35
  uint32_t timeout = SystemCoreClock / 9600;
 80011a4:	fba3 3505 	umull	r3, r5, r3, r5
      __HAL_DMA_DISABLE(hdma);
 80011a8:	6813      	ldr	r3, [r2, #0]
 80011aa:	f023 0301 	bic.w	r3, r3, #1
  uint32_t timeout = SystemCoreClock / 9600;
 80011ae:	0aad      	lsrs	r5, r5, #10
      __HAL_DMA_DISABLE(hdma);
 80011b0:	6013      	str	r3, [r2, #0]
 80011b2:	e002      	b.n	80011ba <HAL_DMA_IRQHandler+0xc6>
        if (++count > timeout)
        {
          break;
        }
      }
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 80011b4:	6813      	ldr	r3, [r2, #0]
 80011b6:	07db      	lsls	r3, r3, #31
 80011b8:	d504      	bpl.n	80011c4 <HAL_DMA_IRQHandler+0xd0>
        if (++count > timeout)
 80011ba:	9b01      	ldr	r3, [sp, #4]
 80011bc:	3301      	adds	r3, #1
 80011be:	42ab      	cmp	r3, r5
 80011c0:	9301      	str	r3, [sp, #4]
 80011c2:	d9f7      	bls.n	80011b4 <HAL_DMA_IRQHandler+0xc0>

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 80011c4:	2200      	movs	r2, #0

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 80011c6:	2301      	movs	r3, #1
      __HAL_UNLOCK(hdma);
 80011c8:	f888 2034 	strb.w	r2, [r8, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
 80011cc:	f888 3035 	strb.w	r3, [r8, #53]	; 0x35
    }

    if(hdma->XferErrorCallback != NULL)
 80011d0:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
 80011d4:	b123      	cbz	r3, 80011e0 <HAL_DMA_IRQHandler+0xec>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 80011d6:	4640      	mov	r0, r8
    }
  }
}
 80011d8:	b002      	add	sp, #8
 80011da:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      hdma->XferErrorCallback(hdma);
 80011de:	4718      	bx	r3
}
 80011e0:	b002      	add	sp, #8
 80011e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 80011e6:	60b2      	str	r2, [r6, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80011e8:	680a      	ldr	r2, [r1, #0]
 80011ea:	f412 2f80 	tst.w	r2, #262144	; 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 80011ee:	680a      	ldr	r2, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80011f0:	d12a      	bne.n	8001248 <HAL_DMA_IRQHandler+0x154>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 80011f2:	05d7      	lsls	r7, r2, #23
 80011f4:	d403      	bmi.n	80011fe <HAL_DMA_IRQHandler+0x10a>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 80011f6:	680a      	ldr	r2, [r1, #0]
 80011f8:	f022 0208 	bic.w	r2, r2, #8
 80011fc:	600a      	str	r2, [r1, #0]
        if(hdma->XferHalfCpltCallback != NULL)
 80011fe:	f8d8 2040 	ldr.w	r2, [r8, #64]	; 0x40
 8001202:	2a00      	cmp	r2, #0
 8001204:	d0a5      	beq.n	8001152 <HAL_DMA_IRQHandler+0x5e>
          hdma->XferHalfCpltCallback(hdma);
 8001206:	4640      	mov	r0, r8
 8001208:	4790      	blx	r2
 800120a:	f8d8 305c 	ldr.w	r3, [r8, #92]	; 0x5c
 800120e:	e7a0      	b.n	8001152 <HAL_DMA_IRQHandler+0x5e>
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8001210:	60b2      	str	r2, [r6, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8001212:	f8d8 2054 	ldr.w	r2, [r8, #84]	; 0x54
 8001216:	f042 0204 	orr.w	r2, r2, #4
 800121a:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
 800121e:	e78f      	b.n	8001140 <HAL_DMA_IRQHandler+0x4c>
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8001220:	60b2      	str	r2, [r6, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8001222:	f8d8 2054 	ldr.w	r2, [r8, #84]	; 0x54
 8001226:	f042 0202 	orr.w	r2, r2, #2
 800122a:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
 800122e:	e77e      	b.n	800112e <HAL_DMA_IRQHandler+0x3a>
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8001230:	680f      	ldr	r7, [r1, #0]
 8001232:	f027 0704 	bic.w	r7, r7, #4
 8001236:	600f      	str	r7, [r1, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8001238:	60b2      	str	r2, [r6, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 800123a:	f8d8 2054 	ldr.w	r2, [r8, #84]	; 0x54
 800123e:	f042 0201 	orr.w	r2, r2, #1
 8001242:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
 8001246:	e769      	b.n	800111c <HAL_DMA_IRQHandler+0x28>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8001248:	0312      	lsls	r2, r2, #12
 800124a:	d5d8      	bpl.n	80011fe <HAL_DMA_IRQHandler+0x10a>
          if(hdma->XferM1HalfCpltCallback != NULL)
 800124c:	f8d8 2048 	ldr.w	r2, [r8, #72]	; 0x48
 8001250:	2a00      	cmp	r2, #0
 8001252:	d1d8      	bne.n	8001206 <HAL_DMA_IRQHandler+0x112>
 8001254:	e77d      	b.n	8001152 <HAL_DMA_IRQHandler+0x5e>
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8001256:	680a      	ldr	r2, [r1, #0]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8001258:	f8d8 4040 	ldr.w	r4, [r8, #64]	; 0x40
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 800125c:	f022 0216 	bic.w	r2, r2, #22
 8001260:	600a      	str	r2, [r1, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 8001262:	694a      	ldr	r2, [r1, #20]
 8001264:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001268:	614a      	str	r2, [r1, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 800126a:	b354      	cbz	r4, 80012c2 <HAL_DMA_IRQHandler+0x1ce>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 800126c:	680a      	ldr	r2, [r1, #0]
 800126e:	f022 0208 	bic.w	r2, r2, #8
 8001272:	600a      	str	r2, [r1, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001274:	223f      	movs	r2, #63	; 0x3f
        __HAL_UNLOCK(hdma);
 8001276:	2400      	movs	r4, #0
        hdma->State = HAL_DMA_STATE_READY;
 8001278:	2101      	movs	r1, #1
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 800127a:	fa02 f303 	lsl.w	r3, r2, r3
        if(hdma->XferAbortCallback != NULL)
 800127e:	f8d8 2050 	ldr.w	r2, [r8, #80]	; 0x50
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001282:	60b3      	str	r3, [r6, #8]
        __HAL_UNLOCK(hdma);
 8001284:	f888 4034 	strb.w	r4, [r8, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_READY;
 8001288:	f888 1035 	strb.w	r1, [r8, #53]	; 0x35
        if(hdma->XferAbortCallback != NULL)
 800128c:	2a00      	cmp	r2, #0
 800128e:	d0a7      	beq.n	80011e0 <HAL_DMA_IRQHandler+0xec>
          hdma->XferAbortCallback(hdma);
 8001290:	4640      	mov	r0, r8
}
 8001292:	b002      	add	sp, #8
 8001294:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
          hdma->XferAbortCallback(hdma);
 8001298:	4710      	bx	r2
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 800129a:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 800129e:	f47f af6f 	bne.w	8001180 <HAL_DMA_IRQHandler+0x8c>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 80012a2:	680a      	ldr	r2, [r1, #0]
          hdma->State = HAL_DMA_STATE_READY;
 80012a4:	2401      	movs	r4, #1
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 80012a6:	f022 0210 	bic.w	r2, r2, #16
 80012aa:	600a      	str	r2, [r1, #0]
          __HAL_UNLOCK(hdma);
 80012ac:	f888 3034 	strb.w	r3, [r8, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
 80012b0:	f888 4035 	strb.w	r4, [r8, #53]	; 0x35
 80012b4:	e764      	b.n	8001180 <HAL_DMA_IRQHandler+0x8c>
          if(hdma->XferM1CpltCallback != NULL)
 80012b6:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
 80012ba:	2b00      	cmp	r3, #0
 80012bc:	f47f af63 	bne.w	8001186 <HAL_DMA_IRQHandler+0x92>
 80012c0:	e763      	b.n	800118a <HAL_DMA_IRQHandler+0x96>
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 80012c2:	f8d8 2048 	ldr.w	r2, [r8, #72]	; 0x48
 80012c6:	2a00      	cmp	r2, #0
 80012c8:	d1d0      	bne.n	800126c <HAL_DMA_IRQHandler+0x178>
 80012ca:	e7d3      	b.n	8001274 <HAL_DMA_IRQHandler+0x180>
 80012cc:	20000000 	.word	0x20000000
 80012d0:	1b4e81b5 	.word	0x1b4e81b5

080012d4 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80012d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 80012d8:	2300      	movs	r3, #0
{
 80012da:	b085      	sub	sp, #20
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80012dc:	f8df b22c 	ldr.w	fp, [pc, #556]	; 800150c <HAL_GPIO_Init+0x238>
 80012e0:	680d      	ldr	r5, [r1, #0]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80012e2:	f8df e22c 	ldr.w	lr, [pc, #556]	; 8001510 <HAL_GPIO_Init+0x23c>
 80012e6:	e002      	b.n	80012ee <HAL_GPIO_Init+0x1a>
  for(position = 0; position < GPIO_NUMBER; position++)
 80012e8:	3301      	adds	r3, #1
 80012ea:	2b10      	cmp	r3, #16
 80012ec:	d057      	beq.n	800139e <HAL_GPIO_Init+0xca>
    ioposition = ((uint32_t)0x01) << position;
 80012ee:	2201      	movs	r2, #1
 80012f0:	409a      	lsls	r2, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80012f2:	ea02 0a05 	and.w	sl, r2, r5
    if(iocurrent == ioposition)
 80012f6:	43aa      	bics	r2, r5
 80012f8:	d1f6      	bne.n	80012e8 <HAL_GPIO_Init+0x14>
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80012fa:	684a      	ldr	r2, [r1, #4]
 80012fc:	005f      	lsls	r7, r3, #1
 80012fe:	f022 0c10 	bic.w	ip, r2, #16
 8001302:	f10c 34ff 	add.w	r4, ip, #4294967295
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001306:	2c01      	cmp	r4, #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8001308:	f04f 0403 	mov.w	r4, #3
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800130c:	f200 80c0 	bhi.w	8001490 <HAL_GPIO_Init+0x1bc>
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001310:	f3c2 1600 	ubfx	r6, r2, #4, #1
        temp = GPIOx->OSPEEDR; 
 8001314:	f8d0 8008 	ldr.w	r8, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8001318:	40bc      	lsls	r4, r7
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800131a:	409e      	lsls	r6, r3
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 800131c:	ea28 0804 	bic.w	r8, r8, r4
 8001320:	43e4      	mvns	r4, r4
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001322:	9601      	str	r6, [sp, #4]
        temp |= (GPIO_Init->Speed << (position * 2));
 8001324:	68ce      	ldr	r6, [r1, #12]
 8001326:	fa06 f907 	lsl.w	r9, r6, r7
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800132a:	9e01      	ldr	r6, [sp, #4]
        temp |= (GPIO_Init->Speed << (position * 2));
 800132c:	ea49 0808 	orr.w	r8, r9, r8
        GPIOx->OSPEEDR = temp;
 8001330:	f8c0 8008 	str.w	r8, [r0, #8]
        temp = GPIOx->OTYPER;
 8001334:	f8d0 8004 	ldr.w	r8, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001338:	ea28 080a 	bic.w	r8, r8, sl
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800133c:	ea46 0608 	orr.w	r6, r6, r8
        GPIOx->OTYPER = temp;
 8001340:	6046      	str	r6, [r0, #4]
      temp = GPIOx->PUPDR;
 8001342:	68c6      	ldr	r6, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001344:	f1bc 0f02 	cmp.w	ip, #2
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8001348:	ea06 0804 	and.w	r8, r6, r4
      temp |= ((GPIO_Init->Pull) << (position * 2));
 800134c:	688e      	ldr	r6, [r1, #8]
 800134e:	fa06 f607 	lsl.w	r6, r6, r7
 8001352:	ea46 0608 	orr.w	r6, r6, r8
      GPIOx->PUPDR = temp;
 8001356:	60c6      	str	r6, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001358:	d124      	bne.n	80013a4 <HAL_GPIO_Init+0xd0>
        temp = GPIOx->AFR[position >> 3];
 800135a:	08de      	lsrs	r6, r3, #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800135c:	f003 0c07 	and.w	ip, r3, #7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001360:	f002 0203 	and.w	r2, r2, #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001364:	f04f 080f 	mov.w	r8, #15
 8001368:	eb00 0686 	add.w	r6, r0, r6, lsl #2
  for(position = 0; position < GPIO_NUMBER; position++)
 800136c:	3301      	adds	r3, #1
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800136e:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001372:	fa02 f707 	lsl.w	r7, r2, r7
        temp = GPIOx->AFR[position >> 3];
 8001376:	f8d6 9020 	ldr.w	r9, [r6, #32]
  for(position = 0; position < GPIO_NUMBER; position++)
 800137a:	2b10      	cmp	r3, #16
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 800137c:	690a      	ldr	r2, [r1, #16]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800137e:	fa08 f80c 	lsl.w	r8, r8, ip
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8001382:	fa02 fc0c 	lsl.w	ip, r2, ip
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001386:	ea29 0208 	bic.w	r2, r9, r8
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 800138a:	ea4c 0202 	orr.w	r2, ip, r2
        GPIOx->AFR[position >> 3] = temp;
 800138e:	6232      	str	r2, [r6, #32]
      temp = GPIOx->MODER;
 8001390:	6802      	ldr	r2, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001392:	ea04 0402 	and.w	r4, r4, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001396:	ea44 0407 	orr.w	r4, r4, r7
      GPIOx->MODER = temp;
 800139a:	6004      	str	r4, [r0, #0]
  for(position = 0; position < GPIO_NUMBER; position++)
 800139c:	d1a7      	bne.n	80012ee <HAL_GPIO_Init+0x1a>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 800139e:	b005      	add	sp, #20
 80013a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      temp = GPIOx->MODER;
 80013a4:	f8d0 c000 	ldr.w	ip, [r0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80013a8:	f002 0603 	and.w	r6, r2, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 80013ac:	ea0c 0c04 	and.w	ip, ip, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80013b0:	fa06 f707 	lsl.w	r7, r6, r7
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80013b4:	00d4      	lsls	r4, r2, #3
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80013b6:	ea47 070c 	orr.w	r7, r7, ip
      GPIOx->MODER = temp;
 80013ba:	6007      	str	r7, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80013bc:	d594      	bpl.n	80012e8 <HAL_GPIO_Init+0x14>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80013be:	f8db 7044 	ldr.w	r7, [fp, #68]	; 0x44
 80013c2:	f023 0c03 	bic.w	ip, r3, #3
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80013c6:	f003 0403 	and.w	r4, r3, #3
 80013ca:	260f      	movs	r6, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80013cc:	f447 4780 	orr.w	r7, r7, #16384	; 0x4000
 80013d0:	f10c 4c80 	add.w	ip, ip, #1073741824	; 0x40000000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80013d4:	00a4      	lsls	r4, r4, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80013d6:	f8cb 7044 	str.w	r7, [fp, #68]	; 0x44
 80013da:	f50c 3c9c 	add.w	ip, ip, #79872	; 0x13800
 80013de:	f8db 7044 	ldr.w	r7, [fp, #68]	; 0x44
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80013e2:	fa06 f804 	lsl.w	r8, r6, r4
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80013e6:	f407 4780 	and.w	r7, r7, #16384	; 0x4000
 80013ea:	9703      	str	r7, [sp, #12]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80013ec:	4f3e      	ldr	r7, [pc, #248]	; (80014e8 <HAL_GPIO_Init+0x214>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80013ee:	9e03      	ldr	r6, [sp, #12]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80013f0:	42b8      	cmp	r0, r7
        temp = SYSCFG->EXTICR[position >> 2];
 80013f2:	f8dc 6008 	ldr.w	r6, [ip, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80013f6:	ea26 0608 	bic.w	r6, r6, r8
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80013fa:	d020      	beq.n	800143e <HAL_GPIO_Init+0x16a>
 80013fc:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 8001400:	42b8      	cmp	r0, r7
 8001402:	d048      	beq.n	8001496 <HAL_GPIO_Init+0x1c2>
 8001404:	4f39      	ldr	r7, [pc, #228]	; (80014ec <HAL_GPIO_Init+0x218>)
 8001406:	42b8      	cmp	r0, r7
 8001408:	d04a      	beq.n	80014a0 <HAL_GPIO_Init+0x1cc>
 800140a:	4f39      	ldr	r7, [pc, #228]	; (80014f0 <HAL_GPIO_Init+0x21c>)
 800140c:	42b8      	cmp	r0, r7
 800140e:	d04c      	beq.n	80014aa <HAL_GPIO_Init+0x1d6>
 8001410:	4f38      	ldr	r7, [pc, #224]	; (80014f4 <HAL_GPIO_Init+0x220>)
 8001412:	42b8      	cmp	r0, r7
 8001414:	d04e      	beq.n	80014b4 <HAL_GPIO_Init+0x1e0>
 8001416:	4f38      	ldr	r7, [pc, #224]	; (80014f8 <HAL_GPIO_Init+0x224>)
 8001418:	42b8      	cmp	r0, r7
 800141a:	d055      	beq.n	80014c8 <HAL_GPIO_Init+0x1f4>
 800141c:	4f37      	ldr	r7, [pc, #220]	; (80014fc <HAL_GPIO_Init+0x228>)
 800141e:	42b8      	cmp	r0, r7
 8001420:	d057      	beq.n	80014d2 <HAL_GPIO_Init+0x1fe>
 8001422:	4f37      	ldr	r7, [pc, #220]	; (8001500 <HAL_GPIO_Init+0x22c>)
 8001424:	42b8      	cmp	r0, r7
 8001426:	d04a      	beq.n	80014be <HAL_GPIO_Init+0x1ea>
 8001428:	4f36      	ldr	r7, [pc, #216]	; (8001504 <HAL_GPIO_Init+0x230>)
 800142a:	42b8      	cmp	r0, r7
 800142c:	d056      	beq.n	80014dc <HAL_GPIO_Init+0x208>
 800142e:	4f36      	ldr	r7, [pc, #216]	; (8001508 <HAL_GPIO_Init+0x234>)
 8001430:	42b8      	cmp	r0, r7
 8001432:	bf0c      	ite	eq
 8001434:	2709      	moveq	r7, #9
 8001436:	270a      	movne	r7, #10
 8001438:	fa07 f404 	lsl.w	r4, r7, r4
 800143c:	4326      	orrs	r6, r4
        SYSCFG->EXTICR[position >> 2] = temp;
 800143e:	f8cc 6008 	str.w	r6, [ip, #8]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001442:	03d7      	lsls	r7, r2, #15
        temp = EXTI->IMR;
 8001444:	f8de 4000 	ldr.w	r4, [lr]
        temp &= ~((uint32_t)iocurrent);
 8001448:	ea6f 060a 	mvn.w	r6, sl
          temp |= iocurrent;
 800144c:	bf4c      	ite	mi
 800144e:	ea4a 0404 	orrmi.w	r4, sl, r4
        temp &= ~((uint32_t)iocurrent);
 8001452:	4034      	andpl	r4, r6
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001454:	0397      	lsls	r7, r2, #14
        EXTI->IMR = temp;
 8001456:	f8ce 4000 	str.w	r4, [lr]
        temp = EXTI->EMR;
 800145a:	f8de 4004 	ldr.w	r4, [lr, #4]
        temp &= ~((uint32_t)iocurrent);
 800145e:	bf54      	ite	pl
 8001460:	4034      	andpl	r4, r6
          temp |= iocurrent;
 8001462:	ea4a 0404 	orrmi.w	r4, sl, r4
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001466:	02d7      	lsls	r7, r2, #11
        EXTI->EMR = temp;
 8001468:	f8ce 4004 	str.w	r4, [lr, #4]
        temp = EXTI->RTSR;
 800146c:	f8de 4008 	ldr.w	r4, [lr, #8]
        temp &= ~((uint32_t)iocurrent);
 8001470:	bf54      	ite	pl
 8001472:	4034      	andpl	r4, r6
          temp |= iocurrent;
 8001474:	ea4a 0404 	orrmi.w	r4, sl, r4
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001478:	0292      	lsls	r2, r2, #10
        EXTI->RTSR = temp;
 800147a:	f8ce 4008 	str.w	r4, [lr, #8]
        temp = EXTI->FTSR;
 800147e:	f8de 400c 	ldr.w	r4, [lr, #12]
        temp &= ~((uint32_t)iocurrent);
 8001482:	bf54      	ite	pl
 8001484:	4034      	andpl	r4, r6
          temp |= iocurrent;
 8001486:	ea4a 0404 	orrmi.w	r4, sl, r4
        EXTI->FTSR = temp;
 800148a:	f8ce 400c 	str.w	r4, [lr, #12]
 800148e:	e72b      	b.n	80012e8 <HAL_GPIO_Init+0x14>
 8001490:	40bc      	lsls	r4, r7
 8001492:	43e4      	mvns	r4, r4
 8001494:	e755      	b.n	8001342 <HAL_GPIO_Init+0x6e>
 8001496:	2701      	movs	r7, #1
 8001498:	fa07 f404 	lsl.w	r4, r7, r4
 800149c:	4326      	orrs	r6, r4
 800149e:	e7ce      	b.n	800143e <HAL_GPIO_Init+0x16a>
 80014a0:	2702      	movs	r7, #2
 80014a2:	fa07 f404 	lsl.w	r4, r7, r4
 80014a6:	4326      	orrs	r6, r4
 80014a8:	e7c9      	b.n	800143e <HAL_GPIO_Init+0x16a>
 80014aa:	2703      	movs	r7, #3
 80014ac:	fa07 f404 	lsl.w	r4, r7, r4
 80014b0:	4326      	orrs	r6, r4
 80014b2:	e7c4      	b.n	800143e <HAL_GPIO_Init+0x16a>
 80014b4:	2704      	movs	r7, #4
 80014b6:	fa07 f404 	lsl.w	r4, r7, r4
 80014ba:	4326      	orrs	r6, r4
 80014bc:	e7bf      	b.n	800143e <HAL_GPIO_Init+0x16a>
 80014be:	2707      	movs	r7, #7
 80014c0:	fa07 f404 	lsl.w	r4, r7, r4
 80014c4:	4326      	orrs	r6, r4
 80014c6:	e7ba      	b.n	800143e <HAL_GPIO_Init+0x16a>
 80014c8:	2705      	movs	r7, #5
 80014ca:	fa07 f404 	lsl.w	r4, r7, r4
 80014ce:	4326      	orrs	r6, r4
 80014d0:	e7b5      	b.n	800143e <HAL_GPIO_Init+0x16a>
 80014d2:	2706      	movs	r7, #6
 80014d4:	fa07 f404 	lsl.w	r4, r7, r4
 80014d8:	4326      	orrs	r6, r4
 80014da:	e7b0      	b.n	800143e <HAL_GPIO_Init+0x16a>
 80014dc:	2708      	movs	r7, #8
 80014de:	fa07 f404 	lsl.w	r4, r7, r4
 80014e2:	4326      	orrs	r6, r4
 80014e4:	e7ab      	b.n	800143e <HAL_GPIO_Init+0x16a>
 80014e6:	bf00      	nop
 80014e8:	40020000 	.word	0x40020000
 80014ec:	40020800 	.word	0x40020800
 80014f0:	40020c00 	.word	0x40020c00
 80014f4:	40021000 	.word	0x40021000
 80014f8:	40021400 	.word	0x40021400
 80014fc:	40021800 	.word	0x40021800
 8001500:	40021c00 	.word	0x40021c00
 8001504:	40022000 	.word	0x40022000
 8001508:	40022400 	.word	0x40022400
 800150c:	40023800 	.word	0x40023800
 8001510:	40013c00 	.word	0x40013c00

08001514 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8001514:	b902      	cbnz	r2, 8001518 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 8001516:	0409      	lsls	r1, r1, #16
 8001518:	6181      	str	r1, [r0, #24]
  }
}
 800151a:	4770      	bx	lr

0800151c <HAL_I2C_EV_IRQHandler>:
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
  /* Get current IT Flags and IT sources value */
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 800151c:	6802      	ldr	r2, [r0, #0]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);

  /* I2C events treatment -------------------------------------*/
  if (hi2c->XferISR != NULL)
 800151e:	6b43      	ldr	r3, [r0, #52]	; 0x34
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 8001520:	6991      	ldr	r1, [r2, #24]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 8001522:	6812      	ldr	r2, [r2, #0]
  if (hi2c->XferISR != NULL)
 8001524:	b103      	cbz	r3, 8001528 <HAL_I2C_EV_IRQHandler+0xc>
  {
    hi2c->XferISR(hi2c, itflags, itsources);
 8001526:	4718      	bx	r3
  }
}
 8001528:	4770      	bx	lr
 800152a:	bf00      	nop

0800152c <HAL_PWREx_EnableOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 800152c:	4a1b      	ldr	r2, [pc, #108]	; (800159c <HAL_PWREx_EnableOverDrive+0x70>)
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 800152e:	4b1c      	ldr	r3, [pc, #112]	; (80015a0 <HAL_PWREx_EnableOverDrive+0x74>)
  __HAL_RCC_PWR_CLK_ENABLE();
 8001530:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8001532:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
{
 8001536:	b570      	push	{r4, r5, r6, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 8001538:	6411      	str	r1, [r2, #64]	; 0x40
{
 800153a:	b082      	sub	sp, #8
  __HAL_RCC_PWR_CLK_ENABLE();
 800153c:	6c12      	ldr	r2, [r2, #64]	; 0x40

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800153e:	461d      	mov	r5, r3
  __HAL_RCC_PWR_CLK_ENABLE();
 8001540:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8001544:	9201      	str	r2, [sp, #4]
 8001546:	9a01      	ldr	r2, [sp, #4]
  __HAL_PWR_OVERDRIVE_ENABLE();
 8001548:	681a      	ldr	r2, [r3, #0]
 800154a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800154e:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8001550:	f7ff fd6e 	bl	8001030 <HAL_GetTick>
 8001554:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8001556:	e005      	b.n	8001564 <HAL_PWREx_EnableOverDrive+0x38>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8001558:	f7ff fd6a 	bl	8001030 <HAL_GetTick>
 800155c:	1b00      	subs	r0, r0, r4
 800155e:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8001562:	d817      	bhi.n	8001594 <HAL_PWREx_EnableOverDrive+0x68>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8001564:	686b      	ldr	r3, [r5, #4]
 8001566:	03da      	lsls	r2, r3, #15
 8001568:	d5f6      	bpl.n	8001558 <HAL_PWREx_EnableOverDrive+0x2c>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 800156a:	682b      	ldr	r3, [r5, #0]

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800156c:	4e0c      	ldr	r6, [pc, #48]	; (80015a0 <HAL_PWREx_EnableOverDrive+0x74>)
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 800156e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001572:	602b      	str	r3, [r5, #0]
  tickstart = HAL_GetTick();
 8001574:	f7ff fd5c 	bl	8001030 <HAL_GetTick>
 8001578:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800157a:	e005      	b.n	8001588 <HAL_PWREx_EnableOverDrive+0x5c>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800157c:	f7ff fd58 	bl	8001030 <HAL_GetTick>
 8001580:	1b00      	subs	r0, r0, r4
 8001582:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8001586:	d805      	bhi.n	8001594 <HAL_PWREx_EnableOverDrive+0x68>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8001588:	6873      	ldr	r3, [r6, #4]
 800158a:	039b      	lsls	r3, r3, #14
 800158c:	d5f6      	bpl.n	800157c <HAL_PWREx_EnableOverDrive+0x50>
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 800158e:	2000      	movs	r0, #0
}
 8001590:	b002      	add	sp, #8
 8001592:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_TIMEOUT;
 8001594:	2003      	movs	r0, #3
}
 8001596:	b002      	add	sp, #8
 8001598:	bd70      	pop	{r4, r5, r6, pc}
 800159a:	bf00      	nop
 800159c:	40023800 	.word	0x40023800
 80015a0:	40007000 	.word	0x40007000

080015a4 <HAL_RCC_OscConfig>:
  uint32_t tickstart;
  uint32_t pll_config;
  FlagStatus pwrclkchanged = RESET;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 80015a4:	2800      	cmp	r0, #0
 80015a6:	f000 81c1 	beq.w	800192c <HAL_RCC_OscConfig+0x388>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80015aa:	6803      	ldr	r3, [r0, #0]
{
 80015ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80015b0:	07dd      	lsls	r5, r3, #31
{
 80015b2:	b082      	sub	sp, #8
 80015b4:	4604      	mov	r4, r0
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80015b6:	d535      	bpl.n	8001624 <HAL_RCC_OscConfig+0x80>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 80015b8:	49ac      	ldr	r1, [pc, #688]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 80015ba:	688a      	ldr	r2, [r1, #8]
 80015bc:	f002 020c 	and.w	r2, r2, #12
 80015c0:	2a04      	cmp	r2, #4
 80015c2:	f000 80e6 	beq.w	8001792 <HAL_RCC_OscConfig+0x1ee>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80015c6:	688a      	ldr	r2, [r1, #8]
 80015c8:	f002 020c 	and.w	r2, r2, #12
 80015cc:	2a08      	cmp	r2, #8
 80015ce:	f000 80dc 	beq.w	800178a <HAL_RCC_OscConfig+0x1e6>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80015d2:	6863      	ldr	r3, [r4, #4]
 80015d4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80015d8:	d010      	beq.n	80015fc <HAL_RCC_OscConfig+0x58>
 80015da:	2b00      	cmp	r3, #0
 80015dc:	f000 8104 	beq.w	80017e8 <HAL_RCC_OscConfig+0x244>
 80015e0:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80015e4:	4ba1      	ldr	r3, [pc, #644]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 80015e6:	681a      	ldr	r2, [r3, #0]
 80015e8:	f000 8190 	beq.w	800190c <HAL_RCC_OscConfig+0x368>
 80015ec:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80015f0:	601a      	str	r2, [r3, #0]
 80015f2:	681a      	ldr	r2, [r3, #0]
 80015f4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80015f8:	601a      	str	r2, [r3, #0]
 80015fa:	e004      	b.n	8001606 <HAL_RCC_OscConfig+0x62>
 80015fc:	4a9b      	ldr	r2, [pc, #620]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 80015fe:	6813      	ldr	r3, [r2, #0]
 8001600:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001604:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001606:	f7ff fd13 	bl	8001030 <HAL_GetTick>

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800160a:	4e98      	ldr	r6, [pc, #608]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
        tickstart = HAL_GetTick();
 800160c:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800160e:	e005      	b.n	800161c <HAL_RCC_OscConfig+0x78>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001610:	f7ff fd0e 	bl	8001030 <HAL_GetTick>
 8001614:	1b40      	subs	r0, r0, r5
 8001616:	2864      	cmp	r0, #100	; 0x64
 8001618:	f200 80e2 	bhi.w	80017e0 <HAL_RCC_OscConfig+0x23c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800161c:	6833      	ldr	r3, [r6, #0]
 800161e:	039a      	lsls	r2, r3, #14
 8001620:	d5f6      	bpl.n	8001610 <HAL_RCC_OscConfig+0x6c>
 8001622:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001624:	079f      	lsls	r7, r3, #30
 8001626:	d529      	bpl.n	800167c <HAL_RCC_OscConfig+0xd8>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 8001628:	4a90      	ldr	r2, [pc, #576]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 800162a:	6891      	ldr	r1, [r2, #8]
 800162c:	f011 0f0c 	tst.w	r1, #12
 8001630:	f000 8082 	beq.w	8001738 <HAL_RCC_OscConfig+0x194>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001634:	6891      	ldr	r1, [r2, #8]
 8001636:	f001 010c 	and.w	r1, r1, #12
 800163a:	2908      	cmp	r1, #8
 800163c:	d079      	beq.n	8001732 <HAL_RCC_OscConfig+0x18e>
      }
    }
    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 800163e:	68e3      	ldr	r3, [r4, #12]
 8001640:	2b00      	cmp	r3, #0
 8001642:	f000 8109 	beq.w	8001858 <HAL_RCC_OscConfig+0x2b4>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001646:	4b89      	ldr	r3, [pc, #548]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 8001648:	681a      	ldr	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800164a:	461e      	mov	r6, r3
        __HAL_RCC_HSI_ENABLE();
 800164c:	f042 0201 	orr.w	r2, r2, #1
 8001650:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001652:	f7ff fced 	bl	8001030 <HAL_GetTick>
 8001656:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001658:	e005      	b.n	8001666 <HAL_RCC_OscConfig+0xc2>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800165a:	f7ff fce9 	bl	8001030 <HAL_GetTick>
 800165e:	1b40      	subs	r0, r0, r5
 8001660:	2802      	cmp	r0, #2
 8001662:	f200 80bd 	bhi.w	80017e0 <HAL_RCC_OscConfig+0x23c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001666:	6833      	ldr	r3, [r6, #0]
 8001668:	0798      	lsls	r0, r3, #30
 800166a:	d5f6      	bpl.n	800165a <HAL_RCC_OscConfig+0xb6>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800166c:	6833      	ldr	r3, [r6, #0]
 800166e:	6922      	ldr	r2, [r4, #16]
 8001670:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8001674:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8001678:	6033      	str	r3, [r6, #0]
 800167a:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800167c:	071a      	lsls	r2, r3, #28
 800167e:	d41f      	bmi.n	80016c0 <HAL_RCC_OscConfig+0x11c>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001680:	075d      	lsls	r5, r3, #29
 8001682:	d535      	bpl.n	80016f0 <HAL_RCC_OscConfig+0x14c>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8001684:	4b79      	ldr	r3, [pc, #484]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 8001686:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001688:	00d0      	lsls	r0, r2, #3
 800168a:	d573      	bpl.n	8001774 <HAL_RCC_OscConfig+0x1d0>
  FlagStatus pwrclkchanged = RESET;
 800168c:	2500      	movs	r5, #0
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800168e:	4b78      	ldr	r3, [pc, #480]	; (8001870 <HAL_RCC_OscConfig+0x2cc>)
 8001690:	681a      	ldr	r2, [r3, #0]
 8001692:	05d1      	lsls	r1, r2, #23
 8001694:	f140 8093 	bpl.w	80017be <HAL_RCC_OscConfig+0x21a>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001698:	68a3      	ldr	r3, [r4, #8]
 800169a:	2b01      	cmp	r3, #1
 800169c:	f000 80f4 	beq.w	8001888 <HAL_RCC_OscConfig+0x2e4>
 80016a0:	2b00      	cmp	r3, #0
 80016a2:	f000 80b8 	beq.w	8001816 <HAL_RCC_OscConfig+0x272>
 80016a6:	2b05      	cmp	r3, #5
 80016a8:	4b70      	ldr	r3, [pc, #448]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 80016aa:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80016ac:	f000 8136 	beq.w	800191c <HAL_RCC_OscConfig+0x378>
 80016b0:	f022 0201 	bic.w	r2, r2, #1
 80016b4:	671a      	str	r2, [r3, #112]	; 0x70
 80016b6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80016b8:	f022 0204 	bic.w	r2, r2, #4
 80016bc:	671a      	str	r2, [r3, #112]	; 0x70
 80016be:	e0e8      	b.n	8001892 <HAL_RCC_OscConfig+0x2ee>
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 80016c0:	6963      	ldr	r3, [r4, #20]
 80016c2:	2b00      	cmp	r3, #0
 80016c4:	d043      	beq.n	800174e <HAL_RCC_OscConfig+0x1aa>
      __HAL_RCC_LSI_ENABLE();
 80016c6:	4b69      	ldr	r3, [pc, #420]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 80016c8:	6f5a      	ldr	r2, [r3, #116]	; 0x74
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80016ca:	461e      	mov	r6, r3
      __HAL_RCC_LSI_ENABLE();
 80016cc:	f042 0201 	orr.w	r2, r2, #1
 80016d0:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 80016d2:	f7ff fcad 	bl	8001030 <HAL_GetTick>
 80016d6:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80016d8:	e004      	b.n	80016e4 <HAL_RCC_OscConfig+0x140>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80016da:	f7ff fca9 	bl	8001030 <HAL_GetTick>
 80016de:	1b40      	subs	r0, r0, r5
 80016e0:	2802      	cmp	r0, #2
 80016e2:	d87d      	bhi.n	80017e0 <HAL_RCC_OscConfig+0x23c>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80016e4:	6f73      	ldr	r3, [r6, #116]	; 0x74
 80016e6:	079b      	lsls	r3, r3, #30
 80016e8:	d5f7      	bpl.n	80016da <HAL_RCC_OscConfig+0x136>
 80016ea:	6823      	ldr	r3, [r4, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80016ec:	075d      	lsls	r5, r3, #29
 80016ee:	d4c9      	bmi.n	8001684 <HAL_RCC_OscConfig+0xe0>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80016f0:	69a0      	ldr	r0, [r4, #24]
 80016f2:	b1d0      	cbz	r0, 800172a <HAL_RCC_OscConfig+0x186>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80016f4:	4b5d      	ldr	r3, [pc, #372]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 80016f6:	689a      	ldr	r2, [r3, #8]
 80016f8:	f002 020c 	and.w	r2, r2, #12
 80016fc:	2a08      	cmp	r2, #8
 80016fe:	f000 80db 	beq.w	80018b8 <HAL_RCC_OscConfig+0x314>
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001702:	681a      	ldr	r2, [r3, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001704:	2802      	cmp	r0, #2

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001706:	461d      	mov	r5, r3
        __HAL_RCC_PLL_DISABLE();
 8001708:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 800170c:	601a      	str	r2, [r3, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800170e:	f000 810f 	beq.w	8001930 <HAL_RCC_OscConfig+0x38c>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001712:	f7ff fc8d 	bl	8001030 <HAL_GetTick>
 8001716:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001718:	e004      	b.n	8001724 <HAL_RCC_OscConfig+0x180>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800171a:	f7ff fc89 	bl	8001030 <HAL_GetTick>
 800171e:	1b00      	subs	r0, r0, r4
 8001720:	2802      	cmp	r0, #2
 8001722:	d85d      	bhi.n	80017e0 <HAL_RCC_OscConfig+0x23c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001724:	682b      	ldr	r3, [r5, #0]
 8001726:	019b      	lsls	r3, r3, #6
 8001728:	d4f7      	bmi.n	800171a <HAL_RCC_OscConfig+0x176>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 800172a:	2000      	movs	r0, #0
}
 800172c:	b002      	add	sp, #8
 800172e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001732:	6852      	ldr	r2, [r2, #4]
 8001734:	0256      	lsls	r6, r2, #9
 8001736:	d482      	bmi.n	800163e <HAL_RCC_OscConfig+0x9a>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001738:	4a4c      	ldr	r2, [pc, #304]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 800173a:	6812      	ldr	r2, [r2, #0]
 800173c:	0795      	lsls	r5, r2, #30
 800173e:	d532      	bpl.n	80017a6 <HAL_RCC_OscConfig+0x202>
 8001740:	68e2      	ldr	r2, [r4, #12]
 8001742:	2a01      	cmp	r2, #1
 8001744:	d02f      	beq.n	80017a6 <HAL_RCC_OscConfig+0x202>
        return HAL_ERROR;
 8001746:	2001      	movs	r0, #1
}
 8001748:	b002      	add	sp, #8
 800174a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 800174e:	4b47      	ldr	r3, [pc, #284]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 8001750:	6f5a      	ldr	r2, [r3, #116]	; 0x74
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001752:	461e      	mov	r6, r3
      __HAL_RCC_LSI_DISABLE();
 8001754:	f022 0201 	bic.w	r2, r2, #1
 8001758:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 800175a:	f7ff fc69 	bl	8001030 <HAL_GetTick>
 800175e:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001760:	e004      	b.n	800176c <HAL_RCC_OscConfig+0x1c8>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001762:	f7ff fc65 	bl	8001030 <HAL_GetTick>
 8001766:	1b40      	subs	r0, r0, r5
 8001768:	2802      	cmp	r0, #2
 800176a:	d839      	bhi.n	80017e0 <HAL_RCC_OscConfig+0x23c>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800176c:	6f73      	ldr	r3, [r6, #116]	; 0x74
 800176e:	079f      	lsls	r7, r3, #30
 8001770:	d4f7      	bmi.n	8001762 <HAL_RCC_OscConfig+0x1be>
 8001772:	e7ba      	b.n	80016ea <HAL_RCC_OscConfig+0x146>
      __HAL_RCC_PWR_CLK_ENABLE();
 8001774:	6c1a      	ldr	r2, [r3, #64]	; 0x40
      pwrclkchanged = SET;
 8001776:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 8001778:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800177c:	641a      	str	r2, [r3, #64]	; 0x40
 800177e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001780:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001784:	9301      	str	r3, [sp, #4]
 8001786:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8001788:	e781      	b.n	800168e <HAL_RCC_OscConfig+0xea>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800178a:	684a      	ldr	r2, [r1, #4]
 800178c:	0250      	lsls	r0, r2, #9
 800178e:	f57f af20 	bpl.w	80015d2 <HAL_RCC_OscConfig+0x2e>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001792:	4a36      	ldr	r2, [pc, #216]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 8001794:	6812      	ldr	r2, [r2, #0]
 8001796:	0391      	lsls	r1, r2, #14
 8001798:	f57f af44 	bpl.w	8001624 <HAL_RCC_OscConfig+0x80>
 800179c:	6862      	ldr	r2, [r4, #4]
 800179e:	2a00      	cmp	r2, #0
 80017a0:	f47f af40 	bne.w	8001624 <HAL_RCC_OscConfig+0x80>
 80017a4:	e7cf      	b.n	8001746 <HAL_RCC_OscConfig+0x1a2>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80017a6:	4931      	ldr	r1, [pc, #196]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 80017a8:	6920      	ldr	r0, [r4, #16]
 80017aa:	680a      	ldr	r2, [r1, #0]
 80017ac:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 80017b0:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 80017b4:	600a      	str	r2, [r1, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80017b6:	071a      	lsls	r2, r3, #28
 80017b8:	f57f af62 	bpl.w	8001680 <HAL_RCC_OscConfig+0xdc>
 80017bc:	e780      	b.n	80016c0 <HAL_RCC_OscConfig+0x11c>
      PWR->CR1 |= PWR_CR1_DBP;
 80017be:	681a      	ldr	r2, [r3, #0]
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80017c0:	461f      	mov	r7, r3
      PWR->CR1 |= PWR_CR1_DBP;
 80017c2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80017c6:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 80017c8:	f7ff fc32 	bl	8001030 <HAL_GetTick>
 80017cc:	4606      	mov	r6, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80017ce:	683b      	ldr	r3, [r7, #0]
 80017d0:	05da      	lsls	r2, r3, #23
 80017d2:	f53f af61 	bmi.w	8001698 <HAL_RCC_OscConfig+0xf4>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80017d6:	f7ff fc2b 	bl	8001030 <HAL_GetTick>
 80017da:	1b80      	subs	r0, r0, r6
 80017dc:	2864      	cmp	r0, #100	; 0x64
 80017de:	d9f6      	bls.n	80017ce <HAL_RCC_OscConfig+0x22a>
            return HAL_TIMEOUT;
 80017e0:	2003      	movs	r0, #3
}
 80017e2:	b002      	add	sp, #8
 80017e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80017e8:	4b20      	ldr	r3, [pc, #128]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 80017ea:	681a      	ldr	r2, [r3, #0]
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80017ec:	461e      	mov	r6, r3
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80017ee:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80017f2:	601a      	str	r2, [r3, #0]
 80017f4:	681a      	ldr	r2, [r3, #0]
 80017f6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80017fa:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80017fc:	f7ff fc18 	bl	8001030 <HAL_GetTick>
 8001800:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001802:	e004      	b.n	800180e <HAL_RCC_OscConfig+0x26a>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001804:	f7ff fc14 	bl	8001030 <HAL_GetTick>
 8001808:	1b40      	subs	r0, r0, r5
 800180a:	2864      	cmp	r0, #100	; 0x64
 800180c:	d8e8      	bhi.n	80017e0 <HAL_RCC_OscConfig+0x23c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800180e:	6833      	ldr	r3, [r6, #0]
 8001810:	039b      	lsls	r3, r3, #14
 8001812:	d4f7      	bmi.n	8001804 <HAL_RCC_OscConfig+0x260>
 8001814:	e705      	b.n	8001622 <HAL_RCC_OscConfig+0x7e>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001816:	4b15      	ldr	r3, [pc, #84]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001818:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800181c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800181e:	461f      	mov	r7, r3
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001820:	f022 0201 	bic.w	r2, r2, #1
 8001824:	671a      	str	r2, [r3, #112]	; 0x70
 8001826:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001828:	f022 0204 	bic.w	r2, r2, #4
 800182c:	671a      	str	r2, [r3, #112]	; 0x70
      tickstart = HAL_GetTick();
 800182e:	f7ff fbff 	bl	8001030 <HAL_GetTick>
 8001832:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001834:	e004      	b.n	8001840 <HAL_RCC_OscConfig+0x29c>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001836:	f7ff fbfb 	bl	8001030 <HAL_GetTick>
 800183a:	1b80      	subs	r0, r0, r6
 800183c:	4540      	cmp	r0, r8
 800183e:	d8cf      	bhi.n	80017e0 <HAL_RCC_OscConfig+0x23c>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001840:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8001842:	0798      	lsls	r0, r3, #30
 8001844:	d4f7      	bmi.n	8001836 <HAL_RCC_OscConfig+0x292>
    if (pwrclkchanged == SET)
 8001846:	2d00      	cmp	r5, #0
 8001848:	f43f af52 	beq.w	80016f0 <HAL_RCC_OscConfig+0x14c>
      __HAL_RCC_PWR_CLK_DISABLE();
 800184c:	4a07      	ldr	r2, [pc, #28]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 800184e:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8001850:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001854:	6413      	str	r3, [r2, #64]	; 0x40
 8001856:	e74b      	b.n	80016f0 <HAL_RCC_OscConfig+0x14c>
        __HAL_RCC_HSI_DISABLE();
 8001858:	4b04      	ldr	r3, [pc, #16]	; (800186c <HAL_RCC_OscConfig+0x2c8>)
 800185a:	681a      	ldr	r2, [r3, #0]
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800185c:	461e      	mov	r6, r3
        __HAL_RCC_HSI_DISABLE();
 800185e:	f022 0201 	bic.w	r2, r2, #1
 8001862:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001864:	f7ff fbe4 	bl	8001030 <HAL_GetTick>
 8001868:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800186a:	e008      	b.n	800187e <HAL_RCC_OscConfig+0x2da>
 800186c:	40023800 	.word	0x40023800
 8001870:	40007000 	.word	0x40007000
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001874:	f7ff fbdc 	bl	8001030 <HAL_GetTick>
 8001878:	1b40      	subs	r0, r0, r5
 800187a:	2802      	cmp	r0, #2
 800187c:	d8b0      	bhi.n	80017e0 <HAL_RCC_OscConfig+0x23c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800187e:	6833      	ldr	r3, [r6, #0]
 8001880:	0799      	lsls	r1, r3, #30
 8001882:	d4f7      	bmi.n	8001874 <HAL_RCC_OscConfig+0x2d0>
 8001884:	6823      	ldr	r3, [r4, #0]
 8001886:	e6f9      	b.n	800167c <HAL_RCC_OscConfig+0xd8>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001888:	4a42      	ldr	r2, [pc, #264]	; (8001994 <HAL_RCC_OscConfig+0x3f0>)
 800188a:	6f13      	ldr	r3, [r2, #112]	; 0x70
 800188c:	f043 0301 	orr.w	r3, r3, #1
 8001890:	6713      	str	r3, [r2, #112]	; 0x70
      tickstart = HAL_GetTick();
 8001892:	f7ff fbcd 	bl	8001030 <HAL_GetTick>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001896:	4f3f      	ldr	r7, [pc, #252]	; (8001994 <HAL_RCC_OscConfig+0x3f0>)
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001898:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 800189c:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800189e:	e004      	b.n	80018aa <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80018a0:	f7ff fbc6 	bl	8001030 <HAL_GetTick>
 80018a4:	1b80      	subs	r0, r0, r6
 80018a6:	4540      	cmp	r0, r8
 80018a8:	d89a      	bhi.n	80017e0 <HAL_RCC_OscConfig+0x23c>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80018aa:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80018ac:	079b      	lsls	r3, r3, #30
 80018ae:	d5f7      	bpl.n	80018a0 <HAL_RCC_OscConfig+0x2fc>
    if (pwrclkchanged == SET)
 80018b0:	2d00      	cmp	r5, #0
 80018b2:	f43f af1d 	beq.w	80016f0 <HAL_RCC_OscConfig+0x14c>
 80018b6:	e7c9      	b.n	800184c <HAL_RCC_OscConfig+0x2a8>
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80018b8:	2801      	cmp	r0, #1
      pll_config = RCC->PLLCFGR;
 80018ba:	685a      	ldr	r2, [r3, #4]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80018bc:	f43f af36 	beq.w	800172c <HAL_RCC_OscConfig+0x188>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80018c0:	f402 0380 	and.w	r3, r2, #4194304	; 0x400000
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80018c4:	69e1      	ldr	r1, [r4, #28]
 80018c6:	428b      	cmp	r3, r1
 80018c8:	f47f af3d 	bne.w	8001746 <HAL_RCC_OscConfig+0x1a2>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 80018cc:	f002 033f 	and.w	r3, r2, #63	; 0x3f
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80018d0:	6a21      	ldr	r1, [r4, #32]
 80018d2:	428b      	cmp	r3, r1
 80018d4:	f47f af37 	bne.w	8001746 <HAL_RCC_OscConfig+0x1a2>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 80018d8:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80018dc:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80018de:	4013      	ands	r3, r2
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 80018e0:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
 80018e4:	f47f af2f 	bne.w	8001746 <HAL_RCC_OscConfig+0x1a2>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 80018e8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80018ea:	f402 3140 	and.w	r1, r2, #196608	; 0x30000
 80018ee:	085b      	lsrs	r3, r3, #1
 80018f0:	3b01      	subs	r3, #1
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 80018f2:	ebb1 4f03 	cmp.w	r1, r3, lsl #16
 80018f6:	f47f af26 	bne.w	8001746 <HAL_RCC_OscConfig+0x1a2>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 80018fa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80018fc:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 8001900:	ebb2 6f03 	cmp.w	r2, r3, lsl #24
  return HAL_OK;
 8001904:	bf14      	ite	ne
 8001906:	2001      	movne	r0, #1
 8001908:	2000      	moveq	r0, #0
 800190a:	e70f      	b.n	800172c <HAL_RCC_OscConfig+0x188>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800190c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8001910:	601a      	str	r2, [r3, #0]
 8001912:	681a      	ldr	r2, [r3, #0]
 8001914:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001918:	601a      	str	r2, [r3, #0]
 800191a:	e674      	b.n	8001606 <HAL_RCC_OscConfig+0x62>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800191c:	f042 0204 	orr.w	r2, r2, #4
 8001920:	671a      	str	r2, [r3, #112]	; 0x70
 8001922:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001924:	f042 0201 	orr.w	r2, r2, #1
 8001928:	671a      	str	r2, [r3, #112]	; 0x70
 800192a:	e7b2      	b.n	8001892 <HAL_RCC_OscConfig+0x2ee>
    return HAL_ERROR;
 800192c:	2001      	movs	r0, #1
}
 800192e:	4770      	bx	lr
        tickstart = HAL_GetTick();
 8001930:	f7ff fb7e 	bl	8001030 <HAL_GetTick>
 8001934:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001936:	e005      	b.n	8001944 <HAL_RCC_OscConfig+0x3a0>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001938:	f7ff fb7a 	bl	8001030 <HAL_GetTick>
 800193c:	1b80      	subs	r0, r0, r6
 800193e:	2802      	cmp	r0, #2
 8001940:	f63f af4e 	bhi.w	80017e0 <HAL_RCC_OscConfig+0x23c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001944:	682b      	ldr	r3, [r5, #0]
 8001946:	0199      	lsls	r1, r3, #6
 8001948:	d4f6      	bmi.n	8001938 <HAL_RCC_OscConfig+0x394>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800194a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800194c:	69e3      	ldr	r3, [r4, #28]
 800194e:	0852      	lsrs	r2, r2, #1
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001950:	4e10      	ldr	r6, [pc, #64]	; (8001994 <HAL_RCC_OscConfig+0x3f0>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001952:	e9d4 1008 	ldrd	r1, r0, [r4, #32]
 8001956:	3a01      	subs	r2, #1
 8001958:	430b      	orrs	r3, r1
 800195a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800195c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001960:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8001964:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8001968:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800196c:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 800196e:	682b      	ldr	r3, [r5, #0]
 8001970:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001974:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8001976:	f7ff fb5b 	bl	8001030 <HAL_GetTick>
 800197a:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800197c:	e005      	b.n	800198a <HAL_RCC_OscConfig+0x3e6>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800197e:	f7ff fb57 	bl	8001030 <HAL_GetTick>
 8001982:	1b00      	subs	r0, r0, r4
 8001984:	2802      	cmp	r0, #2
 8001986:	f63f af2b 	bhi.w	80017e0 <HAL_RCC_OscConfig+0x23c>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800198a:	6833      	ldr	r3, [r6, #0]
 800198c:	019a      	lsls	r2, r3, #6
 800198e:	d5f6      	bpl.n	800197e <HAL_RCC_OscConfig+0x3da>
 8001990:	e6cb      	b.n	800172a <HAL_RCC_OscConfig+0x186>
 8001992:	bf00      	nop
 8001994:	40023800 	.word	0x40023800

08001998 <HAL_RCC_ClockConfig>:
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
  uint32_t tickstart = 0;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 8001998:	2800      	cmp	r0, #0
 800199a:	f000 80b4 	beq.w	8001b06 <HAL_RCC_ClockConfig+0x16e>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800199e:	4a61      	ldr	r2, [pc, #388]	; (8001b24 <HAL_RCC_ClockConfig+0x18c>)
 80019a0:	6813      	ldr	r3, [r2, #0]
 80019a2:	f003 030f 	and.w	r3, r3, #15
 80019a6:	428b      	cmp	r3, r1
{
 80019a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80019ac:	4604      	mov	r4, r0
 80019ae:	460d      	mov	r5, r1
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 80019b0:	d20c      	bcs.n	80019cc <HAL_RCC_ClockConfig+0x34>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80019b2:	6813      	ldr	r3, [r2, #0]
 80019b4:	f023 030f 	bic.w	r3, r3, #15
 80019b8:	430b      	orrs	r3, r1
 80019ba:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 80019bc:	6813      	ldr	r3, [r2, #0]
 80019be:	f003 030f 	and.w	r3, r3, #15
 80019c2:	428b      	cmp	r3, r1
 80019c4:	d002      	beq.n	80019cc <HAL_RCC_ClockConfig+0x34>
    return HAL_ERROR;
 80019c6:	2001      	movs	r0, #1

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick(uwTickPrio);

  return HAL_OK;
}
 80019c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80019cc:	6823      	ldr	r3, [r4, #0]
 80019ce:	0798      	lsls	r0, r3, #30
 80019d0:	d514      	bpl.n	80019fc <HAL_RCC_ClockConfig+0x64>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80019d2:	0759      	lsls	r1, r3, #29
 80019d4:	d504      	bpl.n	80019e0 <HAL_RCC_ClockConfig+0x48>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80019d6:	4954      	ldr	r1, [pc, #336]	; (8001b28 <HAL_RCC_ClockConfig+0x190>)
 80019d8:	688a      	ldr	r2, [r1, #8]
 80019da:	f442 52e0 	orr.w	r2, r2, #7168	; 0x1c00
 80019de:	608a      	str	r2, [r1, #8]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80019e0:	071a      	lsls	r2, r3, #28
 80019e2:	d504      	bpl.n	80019ee <HAL_RCC_ClockConfig+0x56>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80019e4:	4950      	ldr	r1, [pc, #320]	; (8001b28 <HAL_RCC_ClockConfig+0x190>)
 80019e6:	688a      	ldr	r2, [r1, #8]
 80019e8:	f442 4260 	orr.w	r2, r2, #57344	; 0xe000
 80019ec:	608a      	str	r2, [r1, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80019ee:	494e      	ldr	r1, [pc, #312]	; (8001b28 <HAL_RCC_ClockConfig+0x190>)
 80019f0:	68a0      	ldr	r0, [r4, #8]
 80019f2:	688a      	ldr	r2, [r1, #8]
 80019f4:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80019f8:	4302      	orrs	r2, r0
 80019fa:	608a      	str	r2, [r1, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80019fc:	07df      	lsls	r7, r3, #31
 80019fe:	d521      	bpl.n	8001a44 <HAL_RCC_ClockConfig+0xac>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001a00:	6862      	ldr	r2, [r4, #4]
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001a02:	4b49      	ldr	r3, [pc, #292]	; (8001b28 <HAL_RCC_ClockConfig+0x190>)
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001a04:	2a01      	cmp	r2, #1
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001a06:	681b      	ldr	r3, [r3, #0]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001a08:	d07f      	beq.n	8001b0a <HAL_RCC_ClockConfig+0x172>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001a0a:	2a02      	cmp	r2, #2
 8001a0c:	d078      	beq.n	8001b00 <HAL_RCC_ClockConfig+0x168>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001a0e:	0799      	lsls	r1, r3, #30
 8001a10:	d5d9      	bpl.n	80019c6 <HAL_RCC_ClockConfig+0x2e>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001a12:	4945      	ldr	r1, [pc, #276]	; (8001b28 <HAL_RCC_ClockConfig+0x190>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001a14:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001a18:	688b      	ldr	r3, [r1, #8]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8001a1a:	460f      	mov	r7, r1
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001a1c:	f023 0303 	bic.w	r3, r3, #3
 8001a20:	4313      	orrs	r3, r2
 8001a22:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8001a24:	f7ff fb04 	bl	8001030 <HAL_GetTick>
 8001a28:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8001a2a:	e004      	b.n	8001a36 <HAL_RCC_ClockConfig+0x9e>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001a2c:	f7ff fb00 	bl	8001030 <HAL_GetTick>
 8001a30:	1b80      	subs	r0, r0, r6
 8001a32:	4540      	cmp	r0, r8
 8001a34:	d86c      	bhi.n	8001b10 <HAL_RCC_ClockConfig+0x178>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8001a36:	68bb      	ldr	r3, [r7, #8]
 8001a38:	6862      	ldr	r2, [r4, #4]
 8001a3a:	f003 030c 	and.w	r3, r3, #12
 8001a3e:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8001a42:	d1f3      	bne.n	8001a2c <HAL_RCC_ClockConfig+0x94>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8001a44:	4a37      	ldr	r2, [pc, #220]	; (8001b24 <HAL_RCC_ClockConfig+0x18c>)
 8001a46:	6813      	ldr	r3, [r2, #0]
 8001a48:	f003 030f 	and.w	r3, r3, #15
 8001a4c:	42ab      	cmp	r3, r5
 8001a4e:	d909      	bls.n	8001a64 <HAL_RCC_ClockConfig+0xcc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001a50:	6813      	ldr	r3, [r2, #0]
 8001a52:	f023 030f 	bic.w	r3, r3, #15
 8001a56:	432b      	orrs	r3, r5
 8001a58:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8001a5a:	6813      	ldr	r3, [r2, #0]
 8001a5c:	f003 030f 	and.w	r3, r3, #15
 8001a60:	42ab      	cmp	r3, r5
 8001a62:	d1b0      	bne.n	80019c6 <HAL_RCC_ClockConfig+0x2e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001a64:	6823      	ldr	r3, [r4, #0]
 8001a66:	075a      	lsls	r2, r3, #29
 8001a68:	d506      	bpl.n	8001a78 <HAL_RCC_ClockConfig+0xe0>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001a6a:	492f      	ldr	r1, [pc, #188]	; (8001b28 <HAL_RCC_ClockConfig+0x190>)
 8001a6c:	68e0      	ldr	r0, [r4, #12]
 8001a6e:	688a      	ldr	r2, [r1, #8]
 8001a70:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 8001a74:	4302      	orrs	r2, r0
 8001a76:	608a      	str	r2, [r1, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001a78:	071b      	lsls	r3, r3, #28
 8001a7a:	d431      	bmi.n	8001ae0 <HAL_RCC_ClockConfig+0x148>
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001a7c:	492a      	ldr	r1, [pc, #168]	; (8001b28 <HAL_RCC_ClockConfig+0x190>)
 8001a7e:	688b      	ldr	r3, [r1, #8]
 8001a80:	f003 030c 	and.w	r3, r3, #12
 8001a84:	2b04      	cmp	r3, #4
 8001a86:	d039      	beq.n	8001afc <HAL_RCC_ClockConfig+0x164>
 8001a88:	2b08      	cmp	r3, #8
 8001a8a:	d118      	bne.n	8001abe <HAL_RCC_ClockConfig+0x126>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001a8c:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8001a8e:	684b      	ldr	r3, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001a90:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8001a94:	6849      	ldr	r1, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8001a96:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
 8001a9a:	d03b      	beq.n	8001b14 <HAL_RCC_ClockConfig+0x17c>
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8001a9c:	4823      	ldr	r0, [pc, #140]	; (8001b2c <HAL_RCC_ClockConfig+0x194>)
 8001a9e:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8001aa2:	2300      	movs	r3, #0
 8001aa4:	fba1 0100 	umull	r0, r1, r1, r0
 8001aa8:	f7fe fbae 	bl	8000208 <__aeabi_uldivmod>
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
 8001aac:	4b1e      	ldr	r3, [pc, #120]	; (8001b28 <HAL_RCC_ClockConfig+0x190>)
 8001aae:	685b      	ldr	r3, [r3, #4]
 8001ab0:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8001ab4:	3301      	adds	r3, #1
 8001ab6:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco / pllp;
 8001ab8:	fbb0 f3f3 	udiv	r3, r0, r3
    {
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
 8001abc:	e000      	b.n	8001ac0 <HAL_RCC_ClockConfig+0x128>
      sysclockfreq = HSI_VALUE;
 8001abe:	4b1c      	ldr	r3, [pc, #112]	; (8001b30 <HAL_RCC_ClockConfig+0x198>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8001ac0:	4a19      	ldr	r2, [pc, #100]	; (8001b28 <HAL_RCC_ClockConfig+0x190>)
 8001ac2:	4c1c      	ldr	r4, [pc, #112]	; (8001b34 <HAL_RCC_ClockConfig+0x19c>)
 8001ac4:	6892      	ldr	r2, [r2, #8]
  HAL_InitTick(uwTickPrio);
 8001ac6:	481c      	ldr	r0, [pc, #112]	; (8001b38 <HAL_RCC_ClockConfig+0x1a0>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8001ac8:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8001acc:	491b      	ldr	r1, [pc, #108]	; (8001b3c <HAL_RCC_ClockConfig+0x1a4>)
  HAL_InitTick(uwTickPrio);
 8001ace:	6800      	ldr	r0, [r0, #0]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8001ad0:	5ca2      	ldrb	r2, [r4, r2]
 8001ad2:	40d3      	lsrs	r3, r2
 8001ad4:	600b      	str	r3, [r1, #0]
  HAL_InitTick(uwTickPrio);
 8001ad6:	f7fe ff75 	bl	80009c4 <HAL_InitTick>
  return HAL_OK;
 8001ada:	2000      	movs	r0, #0
}
 8001adc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8001ae0:	4a11      	ldr	r2, [pc, #68]	; (8001b28 <HAL_RCC_ClockConfig+0x190>)
 8001ae2:	6921      	ldr	r1, [r4, #16]
 8001ae4:	6893      	ldr	r3, [r2, #8]
 8001ae6:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8001aea:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001aee:	490e      	ldr	r1, [pc, #56]	; (8001b28 <HAL_RCC_ClockConfig+0x190>)
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8001af0:	6093      	str	r3, [r2, #8]
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001af2:	688b      	ldr	r3, [r1, #8]
 8001af4:	f003 030c 	and.w	r3, r3, #12
 8001af8:	2b04      	cmp	r3, #4
 8001afa:	d1c5      	bne.n	8001a88 <HAL_RCC_ClockConfig+0xf0>
 8001afc:	4b0b      	ldr	r3, [pc, #44]	; (8001b2c <HAL_RCC_ClockConfig+0x194>)
 8001afe:	e7df      	b.n	8001ac0 <HAL_RCC_ClockConfig+0x128>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001b00:	0198      	lsls	r0, r3, #6
 8001b02:	d486      	bmi.n	8001a12 <HAL_RCC_ClockConfig+0x7a>
 8001b04:	e75f      	b.n	80019c6 <HAL_RCC_ClockConfig+0x2e>
    return HAL_ERROR;
 8001b06:	2001      	movs	r0, #1
}
 8001b08:	4770      	bx	lr
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001b0a:	039e      	lsls	r6, r3, #14
 8001b0c:	d481      	bmi.n	8001a12 <HAL_RCC_ClockConfig+0x7a>
 8001b0e:	e75a      	b.n	80019c6 <HAL_RCC_ClockConfig+0x2e>
        return HAL_TIMEOUT;
 8001b10:	2003      	movs	r0, #3
 8001b12:	e759      	b.n	80019c8 <HAL_RCC_ClockConfig+0x30>
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8001b14:	4806      	ldr	r0, [pc, #24]	; (8001b30 <HAL_RCC_ClockConfig+0x198>)
 8001b16:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8001b1a:	fba1 0100 	umull	r0, r1, r1, r0
 8001b1e:	f7fe fb73 	bl	8000208 <__aeabi_uldivmod>
 8001b22:	e7c3      	b.n	8001aac <HAL_RCC_ClockConfig+0x114>
 8001b24:	40023c00 	.word	0x40023c00
 8001b28:	40023800 	.word	0x40023800
 8001b2c:	017d7840 	.word	0x017d7840
 8001b30:	00f42400 	.word	0x00f42400
 8001b34:	0800271c 	.word	0x0800271c
 8001b38:	20000008 	.word	0x20000008
 8001b3c:	20000000 	.word	0x20000000

08001b40 <HAL_RCC_EnableCSS>:
  SET_BIT(RCC->CR, RCC_CR_CSSON);
 8001b40:	4a02      	ldr	r2, [pc, #8]	; (8001b4c <HAL_RCC_EnableCSS+0xc>)
 8001b42:	6813      	ldr	r3, [r2, #0]
 8001b44:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8001b48:	6013      	str	r3, [r2, #0]
}
 8001b4a:	4770      	bx	lr
 8001b4c:	40023800 	.word	0x40023800

08001b50 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8001b50:	4b04      	ldr	r3, [pc, #16]	; (8001b64 <HAL_RCC_GetPCLK2Freq+0x14>)
 8001b52:	4a05      	ldr	r2, [pc, #20]	; (8001b68 <HAL_RCC_GetPCLK2Freq+0x18>)
 8001b54:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 8001b56:	4905      	ldr	r1, [pc, #20]	; (8001b6c <HAL_RCC_GetPCLK2Freq+0x1c>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8001b58:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8001b5c:	6808      	ldr	r0, [r1, #0]
 8001b5e:	5cd3      	ldrb	r3, [r2, r3]
}
 8001b60:	40d8      	lsrs	r0, r3
 8001b62:	4770      	bx	lr
 8001b64:	40023800 	.word	0x40023800
 8001b68:	0800272c 	.word	0x0800272c
 8001b6c:	20000000 	.word	0x20000000

08001b70 <HAL_RCC_GetClockConfig>:
{
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8001b70:	4b0e      	ldr	r3, [pc, #56]	; (8001bac <HAL_RCC_GetClockConfig+0x3c>)
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8001b72:	220f      	movs	r2, #15
 8001b74:	6002      	str	r2, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8001b76:	689a      	ldr	r2, [r3, #8]
 8001b78:	f002 0203 	and.w	r2, r2, #3
 8001b7c:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 8001b7e:	689a      	ldr	r2, [r3, #8]
 8001b80:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8001b84:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 8001b86:	689a      	ldr	r2, [r3, #8]
 8001b88:	f402 52e0 	and.w	r2, r2, #7168	; 0x1c00
 8001b8c:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8001b8e:	689b      	ldr	r3, [r3, #8]
 8001b90:	08db      	lsrs	r3, r3, #3
{
 8001b92:	b410      	push	{r4}
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8001b94:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8001b98:	4c05      	ldr	r4, [pc, #20]	; (8001bb0 <HAL_RCC_GetClockConfig+0x40>)
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8001b9a:	6103      	str	r3, [r0, #16]
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8001b9c:	6823      	ldr	r3, [r4, #0]
}
 8001b9e:	f85d 4b04 	ldr.w	r4, [sp], #4
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8001ba2:	f003 030f 	and.w	r3, r3, #15
 8001ba6:	600b      	str	r3, [r1, #0]
}
 8001ba8:	4770      	bx	lr
 8001baa:	bf00      	nop
 8001bac:	40023800 	.word	0x40023800
 8001bb0:	40023c00 	.word	0x40023c00

08001bb4 <HAL_RCC_CSSCallback>:
__weak void HAL_RCC_CSSCallback(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RCC_CSSCallback could be implemented in the user file
   */
}
 8001bb4:	4770      	bx	lr
 8001bb6:	bf00      	nop

08001bb8 <HAL_RCC_NMI_IRQHandler>:
{
 8001bb8:	b508      	push	{r3, lr}
  if (__HAL_RCC_GET_IT(RCC_IT_CSS))
 8001bba:	4b05      	ldr	r3, [pc, #20]	; (8001bd0 <HAL_RCC_NMI_IRQHandler+0x18>)
 8001bbc:	68db      	ldr	r3, [r3, #12]
 8001bbe:	061b      	lsls	r3, r3, #24
 8001bc0:	d400      	bmi.n	8001bc4 <HAL_RCC_NMI_IRQHandler+0xc>
}
 8001bc2:	bd08      	pop	{r3, pc}
    HAL_RCC_CSSCallback();
 8001bc4:	f7ff fff6 	bl	8001bb4 <HAL_RCC_CSSCallback>
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
 8001bc8:	4b02      	ldr	r3, [pc, #8]	; (8001bd4 <HAL_RCC_NMI_IRQHandler+0x1c>)
 8001bca:	2280      	movs	r2, #128	; 0x80
 8001bcc:	701a      	strb	r2, [r3, #0]
}
 8001bce:	bd08      	pop	{r3, pc}
 8001bd0:	40023800 	.word	0x40023800
 8001bd4:	4002380e 	.word	0x4002380e

08001bd8 <HAL_RCCEx_PeriphCLKConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8001bd8:	6803      	ldr	r3, [r0, #0]
{
 8001bda:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8001bde:	f013 0601 	ands.w	r6, r3, #1
{
 8001be2:	b083      	sub	sp, #12
 8001be4:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8001be6:	d00b      	beq.n	8001c00 <HAL_RCCEx_PeriphCLKConfig+0x28>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8001be8:	4abb      	ldr	r2, [pc, #748]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001bea:	6891      	ldr	r1, [r2, #8]
 8001bec:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
 8001bf0:	6091      	str	r1, [r2, #8]
 8001bf2:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8001bf4:	6891      	ldr	r1, [r2, #8]

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 8001bf6:	fab0 f680 	clz	r6, r0
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8001bfa:	4301      	orrs	r1, r0
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 8001bfc:	0976      	lsrs	r6, r6, #5
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8001bfe:	6091      	str	r1, [r2, #8]
      plli2sused = 1;
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 8001c00:	f413 2500 	ands.w	r5, r3, #524288	; 0x80000
 8001c04:	d010      	beq.n	8001c28 <HAL_RCCEx_PeriphCLKConfig+0x50>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001c06:	49b4      	ldr	r1, [pc, #720]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001c08:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 8001c0a:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 8001c0e:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001c12:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8001c16:	ea42 0205 	orr.w	r2, r2, r5
 8001c1a:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 8001c1e:	f000 8219 	beq.w	8002054 <HAL_RCCEx_PeriphCLKConfig+0x47c>
    {
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 8001c22:	fab5 f585 	clz	r5, r5
 8001c26:	096d      	lsrs	r5, r5, #5
      pllsaiused = 1;
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 8001c28:	02df      	lsls	r7, r3, #11
 8001c2a:	d510      	bpl.n	8001c4e <HAL_RCCEx_PeriphCLKConfig+0x76>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8001c2c:	48aa      	ldr	r0, [pc, #680]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001c2e:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8001c30:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8001c34:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8001c38:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 8001c3c:	ea42 0201 	orr.w	r2, r2, r1
 8001c40:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8001c44:	f000 8209 	beq.w	800205a <HAL_RCCEx_PeriphCLKConfig+0x482>
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
    {
      pllsaiused = 1;
 8001c48:	2900      	cmp	r1, #0
 8001c4a:	bf08      	it	eq
 8001c4c:	2501      	moveq	r5, #1
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  {
      plli2sused = 1;
 8001c4e:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 8001c52:	bf18      	it	ne
 8001c54:	2601      	movne	r6, #1
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8001c56:	0698      	lsls	r0, r3, #26
 8001c58:	f100 81b6 	bmi.w	8001fc8 <HAL_RCCEx_PeriphCLKConfig+0x3f0>
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8001c5c:	06df      	lsls	r7, r3, #27
 8001c5e:	d50c      	bpl.n	8001c7a <HAL_RCCEx_PeriphCLKConfig+0xa2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8001c60:	4a9d      	ldr	r2, [pc, #628]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001c62:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8001c66:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 8001c6a:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
 8001c6e:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8001c72:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8001c74:	4301      	orrs	r1, r0
 8001c76:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8001c7a:	0458      	lsls	r0, r3, #17
 8001c7c:	d508      	bpl.n	8001c90 <HAL_RCCEx_PeriphCLKConfig+0xb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8001c7e:	4996      	ldr	r1, [pc, #600]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001c80:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8001c82:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001c86:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8001c8a:	4302      	orrs	r2, r0
 8001c8c:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8001c90:	0419      	lsls	r1, r3, #16
 8001c92:	d508      	bpl.n	8001ca6 <HAL_RCCEx_PeriphCLKConfig+0xce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8001c94:	4990      	ldr	r1, [pc, #576]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001c96:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8001c98:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001c9c:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8001ca0:	4302      	orrs	r2, r0
 8001ca2:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8001ca6:	03da      	lsls	r2, r3, #15
 8001ca8:	d508      	bpl.n	8001cbc <HAL_RCCEx_PeriphCLKConfig+0xe4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8001caa:	498b      	ldr	r1, [pc, #556]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001cac:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001cae:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001cb2:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8001cb6:	4302      	orrs	r2, r0
 8001cb8:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8001cbc:	039f      	lsls	r7, r3, #14
 8001cbe:	d508      	bpl.n	8001cd2 <HAL_RCCEx_PeriphCLKConfig+0xfa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8001cc0:	4985      	ldr	r1, [pc, #532]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001cc2:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8001cc4:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001cc8:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 8001ccc:	4302      	orrs	r2, r0
 8001cce:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8001cd2:	0658      	lsls	r0, r3, #25
 8001cd4:	d508      	bpl.n	8001ce8 <HAL_RCCEx_PeriphCLKConfig+0x110>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8001cd6:	4980      	ldr	r1, [pc, #512]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001cd8:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8001cda:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001cde:	f022 0203 	bic.w	r2, r2, #3
 8001ce2:	4302      	orrs	r2, r0
 8001ce4:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8001ce8:	0619      	lsls	r1, r3, #24
 8001cea:	d508      	bpl.n	8001cfe <HAL_RCCEx_PeriphCLKConfig+0x126>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8001cec:	497a      	ldr	r1, [pc, #488]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001cee:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8001cf0:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001cf4:	f022 020c 	bic.w	r2, r2, #12
 8001cf8:	4302      	orrs	r2, r0
 8001cfa:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8001cfe:	05da      	lsls	r2, r3, #23
 8001d00:	d508      	bpl.n	8001d14 <HAL_RCCEx_PeriphCLKConfig+0x13c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8001d02:	4975      	ldr	r1, [pc, #468]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001d04:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8001d06:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001d0a:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8001d0e:	4302      	orrs	r2, r0
 8001d10:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8001d14:	059f      	lsls	r7, r3, #22
 8001d16:	d508      	bpl.n	8001d2a <HAL_RCCEx_PeriphCLKConfig+0x152>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8001d18:	496f      	ldr	r1, [pc, #444]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001d1a:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8001d1c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001d20:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8001d24:	4302      	orrs	r2, r0
 8001d26:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8001d2a:	0558      	lsls	r0, r3, #21
 8001d2c:	d508      	bpl.n	8001d40 <HAL_RCCEx_PeriphCLKConfig+0x168>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8001d2e:	496a      	ldr	r1, [pc, #424]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001d30:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8001d32:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001d36:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001d3a:	4302      	orrs	r2, r0
 8001d3c:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 8001d40:	0519      	lsls	r1, r3, #20
 8001d42:	d508      	bpl.n	8001d56 <HAL_RCCEx_PeriphCLKConfig+0x17e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 8001d44:	4964      	ldr	r1, [pc, #400]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001d46:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8001d48:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001d4c:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8001d50:	4302      	orrs	r2, r0
 8001d52:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 8001d56:	04da      	lsls	r2, r3, #19
 8001d58:	d508      	bpl.n	8001d6c <HAL_RCCEx_PeriphCLKConfig+0x194>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 8001d5a:	495f      	ldr	r1, [pc, #380]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001d5c:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8001d5e:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001d62:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8001d66:	4302      	orrs	r2, r0
 8001d68:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 8001d6c:	049f      	lsls	r7, r3, #18
 8001d6e:	d508      	bpl.n	8001d82 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 8001d70:	4959      	ldr	r1, [pc, #356]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001d72:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8001d74:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001d78:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8001d7c:	4302      	orrs	r2, r0
 8001d7e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8001d82:	0258      	lsls	r0, r3, #9
 8001d84:	d508      	bpl.n	8001d98 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8001d86:	4954      	ldr	r1, [pc, #336]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001d88:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8001d8a:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001d8e:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8001d92:	4302      	orrs	r2, r0
 8001d94:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 8001d98:	0299      	lsls	r1, r3, #10
 8001d9a:	d50c      	bpl.n	8001db6 <HAL_RCCEx_PeriphCLKConfig+0x1de>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8001d9c:	494e      	ldr	r1, [pc, #312]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001d9e:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8001da0:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
    {
      pllsaiused = 1;
 8001da4:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8001da8:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
      pllsaiused = 1;
 8001dac:	bf08      	it	eq
 8001dae:	2501      	moveq	r5, #1
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8001db0:	4302      	orrs	r2, r0
 8001db2:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
  {
    pllsaiused = 1;
 8001db6:	f013 0f08 	tst.w	r3, #8
 8001dba:	bf18      	it	ne
 8001dbc:	2501      	movne	r5, #1
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8001dbe:	035a      	lsls	r2, r3, #13
 8001dc0:	d508      	bpl.n	8001dd4 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8001dc2:	4945      	ldr	r1, [pc, #276]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001dc4:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8001dc6:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001dca:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8001dce:	4302      	orrs	r2, r0
 8001dd0:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 8001dd4:	021f      	lsls	r7, r3, #8
 8001dd6:	d46a      	bmi.n	8001eae <HAL_RCCEx_PeriphCLKConfig+0x2d6>
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 8001dd8:	2e01      	cmp	r6, #1
 8001dda:	d001      	beq.n	8001de0 <HAL_RCCEx_PeriphCLKConfig+0x208>
 8001ddc:	0198      	lsls	r0, r3, #6
 8001dde:	d560      	bpl.n	8001ea2 <HAL_RCCEx_PeriphCLKConfig+0x2ca>
  {
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 8001de0:	4b3d      	ldr	r3, [pc, #244]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001de2:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8001de4:	461f      	mov	r7, r3
    __HAL_RCC_PLLI2S_DISABLE();
 8001de6:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8001dea:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8001dec:	f7ff f920 	bl	8001030 <HAL_GetTick>
 8001df0:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8001df2:	e005      	b.n	8001e00 <HAL_RCCEx_PeriphCLKConfig+0x228>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8001df4:	f7ff f91c 	bl	8001030 <HAL_GetTick>
 8001df8:	1b83      	subs	r3, r0, r6
 8001dfa:	2b64      	cmp	r3, #100	; 0x64
 8001dfc:	f200 80e0 	bhi.w	8001fc0 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8001e00:	683b      	ldr	r3, [r7, #0]
 8001e02:	0119      	lsls	r1, r3, #4
 8001e04:	d4f6      	bmi.n	8001df4 <HAL_RCCEx_PeriphCLKConfig+0x21c>

    /* check for common PLLI2S Parameters */
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));

    /*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 8001e06:	6823      	ldr	r3, [r4, #0]
 8001e08:	07da      	lsls	r2, r3, #31
 8001e0a:	d512      	bpl.n	8001e32 <HAL_RCCEx_PeriphCLKConfig+0x25a>
 8001e0c:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001e0e:	b982      	cbnz	r2, 8001e32 <HAL_RCCEx_PeriphCLKConfig+0x25a>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));

      /* Read PLLI2SP and PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8001e10:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8001e14:	f8d7 6084 	ldr.w	r6, [r7, #132]	; 0x84
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 8001e18:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8001e1c:	6860      	ldr	r0, [r4, #4]
 8001e1e:	f006 6670 	and.w	r6, r6, #251658240	; 0xf000000
 8001e22:	68a1      	ldr	r1, [r4, #8]
 8001e24:	4332      	orrs	r2, r6
 8001e26:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8001e2a:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
 8001e2e:	f8c7 2084 	str.w	r2, [r7, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 8001e32:	031e      	lsls	r6, r3, #12
 8001e34:	d504      	bpl.n	8001e40 <HAL_RCCEx_PeriphCLKConfig+0x268>
 8001e36:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001e38:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 8001e3c:	f000 811e 	beq.w	800207c <HAL_RCCEx_PeriphCLKConfig+0x4a4>
 8001e40:	02d8      	lsls	r0, r3, #11
 8001e42:	d504      	bpl.n	8001e4e <HAL_RCCEx_PeriphCLKConfig+0x276>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 8001e44:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8001e46:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
 8001e4a:	f000 8117 	beq.w	800207c <HAL_RCCEx_PeriphCLKConfig+0x4a4>
      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SPDIF-RX -------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8001e4e:	01d9      	lsls	r1, r3, #7
 8001e50:	d511      	bpl.n	8001e76 <HAL_RCCEx_PeriphCLKConfig+0x29e>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));

     /* Read PLLI2SR value from PLLI2SCFGR register (this value is not needed for SPDIF-RX configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8001e52:	4e21      	ldr	r6, [pc, #132]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* SPDIFCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8001e54:	6860      	ldr	r0, [r4, #4]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8001e56:	f8d6 2084 	ldr.w	r2, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8001e5a:	f8d6 7084 	ldr.w	r7, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8001e5e:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 8001e62:	6921      	ldr	r1, [r4, #16]
 8001e64:	f007 47e0 	and.w	r7, r7, #1879048192	; 0x70000000
 8001e68:	433a      	orrs	r2, r7
 8001e6a:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8001e6e:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8001e72:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is just selected  -----------------*/
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 8001e76:	019a      	lsls	r2, r3, #6
 8001e78:	f100 80f1 	bmi.w	800205e <HAL_RCCEx_PeriphCLKConfig+0x486>
      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
    }

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 8001e7c:	4b16      	ldr	r3, [pc, #88]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001e7e:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8001e80:	461f      	mov	r7, r3
    __HAL_RCC_PLLI2S_ENABLE();
 8001e82:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8001e86:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8001e88:	f7ff f8d2 	bl	8001030 <HAL_GetTick>
 8001e8c:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8001e8e:	e005      	b.n	8001e9c <HAL_RCCEx_PeriphCLKConfig+0x2c4>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8001e90:	f7ff f8ce 	bl	8001030 <HAL_GetTick>
 8001e94:	1b80      	subs	r0, r0, r6
 8001e96:	2864      	cmp	r0, #100	; 0x64
 8001e98:	f200 8092 	bhi.w	8001fc0 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8001e9c:	683b      	ldr	r3, [r7, #0]
 8001e9e:	011b      	lsls	r3, r3, #4
 8001ea0:	d5f6      	bpl.n	8001e90 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 8001ea2:	2d01      	cmp	r5, #1
 8001ea4:	d00e      	beq.n	8001ec4 <HAL_RCCEx_PeriphCLKConfig+0x2ec>
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8001ea6:	2000      	movs	r0, #0
}
 8001ea8:	b003      	add	sp, #12
 8001eaa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8001eae:	490a      	ldr	r1, [pc, #40]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001eb0:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 8001eb4:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001eb8:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8001ebc:	4302      	orrs	r2, r0
 8001ebe:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
 8001ec2:	e789      	b.n	8001dd8 <HAL_RCCEx_PeriphCLKConfig+0x200>
    __HAL_RCC_PLLSAI_DISABLE();
 8001ec4:	4b04      	ldr	r3, [pc, #16]	; (8001ed8 <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8001ec6:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8001ec8:	461e      	mov	r6, r3
    __HAL_RCC_PLLSAI_DISABLE();
 8001eca:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8001ece:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8001ed0:	f7ff f8ae 	bl	8001030 <HAL_GetTick>
 8001ed4:	4605      	mov	r5, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8001ed6:	e006      	b.n	8001ee6 <HAL_RCCEx_PeriphCLKConfig+0x30e>
 8001ed8:	40023800 	.word	0x40023800
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8001edc:	f7ff f8a8 	bl	8001030 <HAL_GetTick>
 8001ee0:	1b40      	subs	r0, r0, r5
 8001ee2:	2864      	cmp	r0, #100	; 0x64
 8001ee4:	d86c      	bhi.n	8001fc0 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8001ee6:	6833      	ldr	r3, [r6, #0]
 8001ee8:	009f      	lsls	r7, r3, #2
 8001eea:	d4f7      	bmi.n	8001edc <HAL_RCCEx_PeriphCLKConfig+0x304>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 8001eec:	6823      	ldr	r3, [r4, #0]
 8001eee:	031d      	lsls	r5, r3, #12
 8001ef0:	f140 80fd 	bpl.w	80020ee <HAL_RCCEx_PeriphCLKConfig+0x516>
 8001ef4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001ef6:	2a00      	cmp	r2, #0
 8001ef8:	f040 80f9 	bne.w	80020ee <HAL_RCCEx_PeriphCLKConfig+0x516>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8001efc:	4980      	ldr	r1, [pc, #512]	; (8002100 <HAL_RCCEx_PeriphCLKConfig+0x528>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8001efe:	6965      	ldr	r5, [r4, #20]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8001f00:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8001f04:	f8d1 6088 	ldr.w	r6, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8001f08:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8001f0c:	69a0      	ldr	r0, [r4, #24]
 8001f0e:	f006 46e0 	and.w	r6, r6, #1879048192	; 0x70000000
 8001f12:	4332      	orrs	r2, r6
 8001f14:	ea42 1285 	orr.w	r2, r2, r5, lsl #6
 8001f18:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8001f1c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 8001f20:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 8001f24:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8001f26:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 8001f2a:	3801      	subs	r0, #1
 8001f2c:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8001f30:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 8001f34:	0299      	lsls	r1, r3, #10
 8001f36:	d515      	bpl.n	8001f64 <HAL_RCCEx_PeriphCLKConfig+0x38c>
 8001f38:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 8001f3a:	f1b2 6f00 	cmp.w	r2, #134217728	; 0x8000000
 8001f3e:	d111      	bne.n	8001f64 <HAL_RCCEx_PeriphCLKConfig+0x38c>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8001f40:	496f      	ldr	r1, [pc, #444]	; (8002100 <HAL_RCCEx_PeriphCLKConfig+0x528>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 8001f42:	6965      	ldr	r5, [r4, #20]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8001f44:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8001f48:	f8d1 6088 	ldr.w	r6, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 8001f4c:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 8001f50:	6a20      	ldr	r0, [r4, #32]
 8001f52:	f006 46e0 	and.w	r6, r6, #1879048192	; 0x70000000
 8001f56:	4332      	orrs	r2, r6
 8001f58:	ea42 1285 	orr.w	r2, r2, r5, lsl #6
 8001f5c:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8001f60:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 8001f64:	071a      	lsls	r2, r3, #28
 8001f66:	d519      	bpl.n	8001f9c <HAL_RCCEx_PeriphCLKConfig+0x3c4>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8001f68:	4a65      	ldr	r2, [pc, #404]	; (8002100 <HAL_RCCEx_PeriphCLKConfig+0x528>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 8001f6a:	6965      	ldr	r5, [r4, #20]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8001f6c:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8001f70:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 8001f74:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
 8001f78:	69e0      	ldr	r0, [r4, #28]
 8001f7a:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8001f7e:	430b      	orrs	r3, r1
 8001f80:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
 8001f84:	ea43 7300 	orr.w	r3, r3, r0, lsl #28
 8001f88:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 8001f8c:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8001f90:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8001f92:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8001f96:	430b      	orrs	r3, r1
 8001f98:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    __HAL_RCC_PLLSAI_ENABLE();
 8001f9c:	4b58      	ldr	r3, [pc, #352]	; (8002100 <HAL_RCCEx_PeriphCLKConfig+0x528>)
 8001f9e:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 8001fa0:	461d      	mov	r5, r3
    __HAL_RCC_PLLSAI_ENABLE();
 8001fa2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001fa6:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8001fa8:	f7ff f842 	bl	8001030 <HAL_GetTick>
 8001fac:	4604      	mov	r4, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 8001fae:	682b      	ldr	r3, [r5, #0]
 8001fb0:	009b      	lsls	r3, r3, #2
 8001fb2:	f53f af78 	bmi.w	8001ea6 <HAL_RCCEx_PeriphCLKConfig+0x2ce>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8001fb6:	f7ff f83b 	bl	8001030 <HAL_GetTick>
 8001fba:	1b00      	subs	r0, r0, r4
 8001fbc:	2864      	cmp	r0, #100	; 0x64
 8001fbe:	d9f6      	bls.n	8001fae <HAL_RCCEx_PeriphCLKConfig+0x3d6>
        return HAL_TIMEOUT;
 8001fc0:	2003      	movs	r0, #3
}
 8001fc2:	b003      	add	sp, #12
 8001fc4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 8001fc8:	4a4d      	ldr	r2, [pc, #308]	; (8002100 <HAL_RCCEx_PeriphCLKConfig+0x528>)
    PWR->CR1 |= PWR_CR1_DBP;
 8001fca:	4b4e      	ldr	r3, [pc, #312]	; (8002104 <HAL_RCCEx_PeriphCLKConfig+0x52c>)
    __HAL_RCC_PWR_CLK_ENABLE();
 8001fcc:	6c11      	ldr	r1, [r2, #64]	; 0x40
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8001fce:	4698      	mov	r8, r3
    __HAL_RCC_PWR_CLK_ENABLE();
 8001fd0:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8001fd4:	6411      	str	r1, [r2, #64]	; 0x40
 8001fd6:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8001fd8:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8001fdc:	9201      	str	r2, [sp, #4]
 8001fde:	9a01      	ldr	r2, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
 8001fe0:	681a      	ldr	r2, [r3, #0]
 8001fe2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001fe6:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8001fe8:	f7ff f822 	bl	8001030 <HAL_GetTick>
 8001fec:	4607      	mov	r7, r0
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8001fee:	e004      	b.n	8001ffa <HAL_RCCEx_PeriphCLKConfig+0x422>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001ff0:	f7ff f81e 	bl	8001030 <HAL_GetTick>
 8001ff4:	1bc0      	subs	r0, r0, r7
 8001ff6:	2864      	cmp	r0, #100	; 0x64
 8001ff8:	d8e2      	bhi.n	8001fc0 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8001ffa:	f8d8 3000 	ldr.w	r3, [r8]
 8001ffe:	05d9      	lsls	r1, r3, #23
 8002000:	d5f6      	bpl.n	8001ff0 <HAL_RCCEx_PeriphCLKConfig+0x418>
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8002002:	4f3f      	ldr	r7, [pc, #252]	; (8002100 <HAL_RCCEx_PeriphCLKConfig+0x528>)
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8002004:	6b23      	ldr	r3, [r4, #48]	; 0x30
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8002006:	6f3a      	ldr	r2, [r7, #112]	; 0x70
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8002008:	f403 7140 	and.w	r1, r3, #768	; 0x300
 800200c:	f412 7240 	ands.w	r2, r2, #768	; 0x300
 8002010:	d010      	beq.n	8002034 <HAL_RCCEx_PeriphCLKConfig+0x45c>
 8002012:	4291      	cmp	r1, r2
 8002014:	d00e      	beq.n	8002034 <HAL_RCCEx_PeriphCLKConfig+0x45c>
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002016:	6f3a      	ldr	r2, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 8002018:	6f38      	ldr	r0, [r7, #112]	; 0x70
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800201a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 800201e:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 8002022:	6738      	str	r0, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 8002024:	6f38      	ldr	r0, [r7, #112]	; 0x70
 8002026:	f420 3080 	bic.w	r0, r0, #65536	; 0x10000
 800202a:	6738      	str	r0, [r7, #112]	; 0x70
      RCC->BDCR = tmpreg0;
 800202c:	673a      	str	r2, [r7, #112]	; 0x70
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 800202e:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8002030:	07d2      	lsls	r2, r2, #31
 8002032:	d448      	bmi.n	80020c6 <HAL_RCCEx_PeriphCLKConfig+0x4ee>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002034:	f5b1 7f40 	cmp.w	r1, #768	; 0x300
 8002038:	d03c      	beq.n	80020b4 <HAL_RCCEx_PeriphCLKConfig+0x4dc>
 800203a:	4931      	ldr	r1, [pc, #196]	; (8002100 <HAL_RCCEx_PeriphCLKConfig+0x528>)
 800203c:	688a      	ldr	r2, [r1, #8]
 800203e:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8002042:	608a      	str	r2, [r1, #8]
 8002044:	4a2e      	ldr	r2, [pc, #184]	; (8002100 <HAL_RCCEx_PeriphCLKConfig+0x528>)
 8002046:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800204a:	6f11      	ldr	r1, [r2, #112]	; 0x70
 800204c:	430b      	orrs	r3, r1
 800204e:	6713      	str	r3, [r2, #112]	; 0x70
 8002050:	6823      	ldr	r3, [r4, #0]
 8002052:	e603      	b.n	8001c5c <HAL_RCCEx_PeriphCLKConfig+0x84>
  uint32_t pllsaiused = 0;
 8002054:	2500      	movs	r5, #0
      plli2sused = 1;
 8002056:	2601      	movs	r6, #1
 8002058:	e5e6      	b.n	8001c28 <HAL_RCCEx_PeriphCLKConfig+0x50>
      plli2sused = 1;
 800205a:	2601      	movs	r6, #1
 800205c:	e5f7      	b.n	8001c4e <HAL_RCCEx_PeriphCLKConfig+0x76>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 800205e:	6923      	ldr	r3, [r4, #16]
 8002060:	6862      	ldr	r2, [r4, #4]
 8002062:	041b      	lsls	r3, r3, #16
 8002064:	e9d4 1002 	ldrd	r1, r0, [r4, #8]
 8002068:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 800206c:	4a24      	ldr	r2, [pc, #144]	; (8002100 <HAL_RCCEx_PeriphCLKConfig+0x528>)
 800206e:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8002072:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 8002076:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
 800207a:	e6ff      	b.n	8001e7c <HAL_RCCEx_PeriphCLKConfig+0x2a4>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 800207c:	4e20      	ldr	r6, [pc, #128]	; (8002100 <HAL_RCCEx_PeriphCLKConfig+0x528>)
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 800207e:	6860      	ldr	r0, [r4, #4]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8002080:	f8d6 2084 	ldr.w	r2, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8002084:	f8d6 7084 	ldr.w	r7, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 8002088:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 800208c:	68e1      	ldr	r1, [r4, #12]
 800208e:	f007 47e0 	and.w	r7, r7, #1879048192	; 0x70000000
 8002092:	433a      	orrs	r2, r7
 8002094:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8002098:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800209c:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 80020a0:	f8d6 108c 	ldr.w	r1, [r6, #140]	; 0x8c
 80020a4:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80020a6:	f021 011f 	bic.w	r1, r1, #31
 80020aa:	3a01      	subs	r2, #1
 80020ac:	430a      	orrs	r2, r1
 80020ae:	f8c6 208c 	str.w	r2, [r6, #140]	; 0x8c
 80020b2:	e6cc      	b.n	8001e4e <HAL_RCCEx_PeriphCLKConfig+0x276>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80020b4:	4812      	ldr	r0, [pc, #72]	; (8002100 <HAL_RCCEx_PeriphCLKConfig+0x528>)
 80020b6:	4914      	ldr	r1, [pc, #80]	; (8002108 <HAL_RCCEx_PeriphCLKConfig+0x530>)
 80020b8:	6882      	ldr	r2, [r0, #8]
 80020ba:	4019      	ands	r1, r3
 80020bc:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 80020c0:	430a      	orrs	r2, r1
 80020c2:	6082      	str	r2, [r0, #8]
 80020c4:	e7be      	b.n	8002044 <HAL_RCCEx_PeriphCLKConfig+0x46c>
        tickstart = HAL_GetTick();
 80020c6:	f7fe ffb3 	bl	8001030 <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80020ca:	f241 3988 	movw	r9, #5000	; 0x1388
        tickstart = HAL_GetTick();
 80020ce:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80020d0:	e006      	b.n	80020e0 <HAL_RCCEx_PeriphCLKConfig+0x508>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80020d2:	f7fe ffad 	bl	8001030 <HAL_GetTick>
 80020d6:	eba0 0008 	sub.w	r0, r0, r8
 80020da:	4548      	cmp	r0, r9
 80020dc:	f63f af70 	bhi.w	8001fc0 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80020e0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80020e2:	079b      	lsls	r3, r3, #30
 80020e4:	d5f5      	bpl.n	80020d2 <HAL_RCCEx_PeriphCLKConfig+0x4fa>
 80020e6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80020e8:	f403 7140 	and.w	r1, r3, #768	; 0x300
 80020ec:	e7a2      	b.n	8002034 <HAL_RCCEx_PeriphCLKConfig+0x45c>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 80020ee:	02d8      	lsls	r0, r3, #11
 80020f0:	f57f af20 	bpl.w	8001f34 <HAL_RCCEx_PeriphCLKConfig+0x35c>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 80020f4:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80020f6:	2a00      	cmp	r2, #0
 80020f8:	f47f af1c 	bne.w	8001f34 <HAL_RCCEx_PeriphCLKConfig+0x35c>
 80020fc:	e6fe      	b.n	8001efc <HAL_RCCEx_PeriphCLKConfig+0x324>
 80020fe:	bf00      	nop
 8002100:	40023800 	.word	0x40023800
 8002104:	40007000 	.word	0x40007000
 8002108:	0ffffcff 	.word	0x0ffffcff

0800210c <HAL_TIM_Base_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if (htim == NULL)
 800210c:	2800      	cmp	r0, #0
 800210e:	f000 8094 	beq.w	800223a <HAL_TIM_Base_Init+0x12e>
{
 8002112:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8002114:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8002118:	4604      	mov	r4, r0
 800211a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800211e:	2b00      	cmp	r3, #0
 8002120:	d07b      	beq.n	800221a <HAL_TIM_Base_Init+0x10e>

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8002122:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8002124:	2302      	movs	r3, #2
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002126:	4947      	ldr	r1, [pc, #284]	; (8002244 <HAL_TIM_Base_Init+0x138>)
 8002128:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
  htim->State = HAL_TIM_STATE_BUSY;
 800212c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002130:	eba2 0101 	sub.w	r1, r2, r1
  tmpcr1 = TIMx->CR1;
 8002134:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002136:	fab1 f181 	clz	r1, r1
 800213a:	ea4f 1151 	mov.w	r1, r1, lsr #5
 800213e:	d050      	beq.n	80021e2 <HAL_TIM_Base_Init+0xd6>
 8002140:	2900      	cmp	r1, #0
 8002142:	d14e      	bne.n	80021e2 <HAL_TIM_Base_Init+0xd6>
 8002144:	4d40      	ldr	r5, [pc, #256]	; (8002248 <HAL_TIM_Base_Init+0x13c>)
 8002146:	4841      	ldr	r0, [pc, #260]	; (800224c <HAL_TIM_Base_Init+0x140>)
 8002148:	4282      	cmp	r2, r0
 800214a:	bf18      	it	ne
 800214c:	42aa      	cmpne	r2, r5
 800214e:	d048      	beq.n	80021e2 <HAL_TIM_Base_Init+0xd6>
 8002150:	4f3f      	ldr	r7, [pc, #252]	; (8002250 <HAL_TIM_Base_Init+0x144>)
 8002152:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8002156:	1bd7      	subs	r7, r2, r7
 8002158:	42aa      	cmp	r2, r5
 800215a:	fab7 f787 	clz	r7, r7
 800215e:	ea4f 1757 	mov.w	r7, r7, lsr #5
 8002162:	d05f      	beq.n	8002224 <HAL_TIM_Base_Init+0x118>
 8002164:	2f00      	cmp	r7, #0
 8002166:	d15d      	bne.n	8002224 <HAL_TIM_Base_Init+0x118>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002168:	4f3a      	ldr	r7, [pc, #232]	; (8002254 <HAL_TIM_Base_Init+0x148>)
 800216a:	483b      	ldr	r0, [pc, #236]	; (8002258 <HAL_TIM_Base_Init+0x14c>)
 800216c:	4282      	cmp	r2, r0
 800216e:	bf18      	it	ne
 8002170:	42ba      	cmpne	r2, r7
 8002172:	bf0c      	ite	eq
 8002174:	2701      	moveq	r7, #1
 8002176:	2700      	movne	r7, #0
 8002178:	d061      	beq.n	800223e <HAL_TIM_Base_Init+0x132>
 800217a:	4d38      	ldr	r5, [pc, #224]	; (800225c <HAL_TIM_Base_Init+0x150>)
 800217c:	f5a0 3096 	sub.w	r0, r0, #76800	; 0x12c00
 8002180:	4282      	cmp	r2, r0
 8002182:	bf18      	it	ne
 8002184:	42aa      	cmpne	r2, r5
 8002186:	d035      	beq.n	80021f4 <HAL_TIM_Base_Init+0xe8>
 8002188:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800218c:	4282      	cmp	r2, r0
 800218e:	d056      	beq.n	800223e <HAL_TIM_Base_Init+0x132>
 8002190:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 8002194:	4282      	cmp	r2, r0
 8002196:	d052      	beq.n	800223e <HAL_TIM_Base_Init+0x132>
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002198:	69a1      	ldr	r1, [r4, #24]
 800219a:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800219e:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80021a0:	430b      	orrs	r3, r1

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 80021a2:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 80021a4:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80021a6:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 80021a8:	6291      	str	r1, [r2, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80021aa:	2301      	movs	r3, #1
  return HAL_OK;
 80021ac:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
 80021ae:	6153      	str	r3, [r2, #20]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 80021b0:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80021b4:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 80021b8:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 80021bc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 80021c0:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 80021c4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80021c8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80021cc:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 80021d0:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80021d4:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
 80021d8:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
  htim->State = HAL_TIM_STATE_READY;
 80021dc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 80021e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80021e2:	4f1b      	ldr	r7, [pc, #108]	; (8002250 <HAL_TIM_Base_Init+0x144>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80021e4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80021e8:	68a5      	ldr	r5, [r4, #8]
 80021ea:	1bd7      	subs	r7, r2, r7
 80021ec:	432b      	orrs	r3, r5
 80021ee:	fab7 f787 	clz	r7, r7
 80021f2:	097f      	lsrs	r7, r7, #5
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80021f4:	6920      	ldr	r0, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 80021f6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80021fa:	69a5      	ldr	r5, [r4, #24]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80021fc:	4303      	orrs	r3, r0
  TIMx->ARR = (uint32_t)Structure->Period ;
 80021fe:	68e6      	ldr	r6, [r4, #12]
  TIMx->PSC = Structure->Prescaler;
 8002200:	6860      	ldr	r0, [r4, #4]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002202:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002206:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 8002208:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800220a:	62d6      	str	r6, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800220c:	6290      	str	r0, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800220e:	b909      	cbnz	r1, 8002214 <HAL_TIM_Base_Init+0x108>
 8002210:	2f00      	cmp	r7, #0
 8002212:	d0ca      	beq.n	80021aa <HAL_TIM_Base_Init+0x9e>
    TIMx->RCR = Structure->RepetitionCounter;
 8002214:	6963      	ldr	r3, [r4, #20]
 8002216:	6313      	str	r3, [r2, #48]	; 0x30
 8002218:	e7c7      	b.n	80021aa <HAL_TIM_Base_Init+0x9e>
    htim->Lock = HAL_UNLOCKED;
 800221a:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 800221e:	f7fe fc85 	bl	8000b2c <HAL_TIM_Base_MspInit>
 8002222:	e77e      	b.n	8002122 <HAL_TIM_Base_Init+0x16>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002224:	480e      	ldr	r0, [pc, #56]	; (8002260 <HAL_TIM_Base_Init+0x154>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002226:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800222a:	68a5      	ldr	r5, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800222c:	4282      	cmp	r2, r0
    tmpcr1 |= Structure->CounterMode;
 800222e:	ea43 0305 	orr.w	r3, r3, r5
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002232:	d0df      	beq.n	80021f4 <HAL_TIM_Base_Init+0xe8>
 8002234:	2f00      	cmp	r7, #0
 8002236:	d1dd      	bne.n	80021f4 <HAL_TIM_Base_Init+0xe8>
 8002238:	e796      	b.n	8002168 <HAL_TIM_Base_Init+0x5c>
    return HAL_ERROR;
 800223a:	2001      	movs	r0, #1
}
 800223c:	4770      	bx	lr
 800223e:	2700      	movs	r7, #0
 8002240:	e7d8      	b.n	80021f4 <HAL_TIM_Base_Init+0xe8>
 8002242:	bf00      	nop
 8002244:	40010000 	.word	0x40010000
 8002248:	40000400 	.word	0x40000400
 800224c:	40000800 	.word	0x40000800
 8002250:	40010400 	.word	0x40010400
 8002254:	40014000 	.word	0x40014000
 8002258:	40014400 	.word	0x40014400
 800225c:	40014800 	.word	0x40014800
 8002260:	40000c00 	.word	0x40000c00

08002264 <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 8002264:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8002268:	2b01      	cmp	r3, #1
 800226a:	d141      	bne.n	80022f0 <HAL_TIM_Base_Start_IT+0x8c>
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800226c:	6802      	ldr	r2, [r0, #0]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800226e:	4b25      	ldr	r3, [pc, #148]	; (8002304 <HAL_TIM_Base_Start_IT+0xa0>)
 8002270:	4925      	ldr	r1, [pc, #148]	; (8002308 <HAL_TIM_Base_Start_IT+0xa4>)
 8002272:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8002276:	bf18      	it	ne
 8002278:	429a      	cmpne	r2, r3
{
 800227a:	b430      	push	{r4, r5}
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800227c:	bf0c      	ite	eq
 800227e:	2301      	moveq	r3, #1
 8002280:	2300      	movne	r3, #0
 8002282:	4c22      	ldr	r4, [pc, #136]	; (800230c <HAL_TIM_Base_Start_IT+0xa8>)
  htim->State = HAL_TIM_STATE_BUSY;
 8002284:	2502      	movs	r5, #2
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8002286:	42a2      	cmp	r2, r4
 8002288:	bf08      	it	eq
 800228a:	f043 0301 	orreq.w	r3, r3, #1
  htim->State = HAL_TIM_STATE_BUSY;
 800228e:	f880 503d 	strb.w	r5, [r0, #61]	; 0x3d
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8002292:	4d1f      	ldr	r5, [pc, #124]	; (8002310 <HAL_TIM_Base_Start_IT+0xac>)
 8002294:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
 8002298:	428a      	cmp	r2, r1
 800229a:	bf08      	it	eq
 800229c:	f043 0301 	orreq.w	r3, r3, #1
 80022a0:	481c      	ldr	r0, [pc, #112]	; (8002314 <HAL_TIM_Base_Start_IT+0xb0>)
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80022a2:	68d1      	ldr	r1, [r2, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80022a4:	42aa      	cmp	r2, r5
 80022a6:	bf08      	it	eq
 80022a8:	f043 0301 	orreq.w	r3, r3, #1
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80022ac:	f041 0101 	orr.w	r1, r1, #1
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80022b0:	42a2      	cmp	r2, r4
 80022b2:	bf08      	it	eq
 80022b4:	f043 0301 	orreq.w	r3, r3, #1
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80022b8:	60d1      	str	r1, [r2, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80022ba:	4282      	cmp	r2, r0
 80022bc:	bf08      	it	eq
 80022be:	f043 0301 	orreq.w	r3, r3, #1
 80022c2:	b933      	cbnz	r3, 80022d2 <HAL_TIM_Base_Start_IT+0x6e>
 80022c4:	f5a0 3094 	sub.w	r0, r0, #75776	; 0x12800
 80022c8:	1a10      	subs	r0, r2, r0
 80022ca:	fab0 f080 	clz	r0, r0
 80022ce:	0940      	lsrs	r0, r0, #5
 80022d0:	b198      	cbz	r0, 80022fa <HAL_TIM_Base_Start_IT+0x96>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80022d2:	6891      	ldr	r1, [r2, #8]
 80022d4:	4b10      	ldr	r3, [pc, #64]	; (8002318 <HAL_TIM_Base_Start_IT+0xb4>)
 80022d6:	400b      	ands	r3, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80022d8:	2b06      	cmp	r3, #6
 80022da:	d00b      	beq.n	80022f4 <HAL_TIM_Base_Start_IT+0x90>
 80022dc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80022e0:	d008      	beq.n	80022f4 <HAL_TIM_Base_Start_IT+0x90>
      __HAL_TIM_ENABLE(htim);
 80022e2:	6813      	ldr	r3, [r2, #0]
  return HAL_OK;
 80022e4:	2000      	movs	r0, #0
      __HAL_TIM_ENABLE(htim);
 80022e6:	f043 0301 	orr.w	r3, r3, #1
 80022ea:	6013      	str	r3, [r2, #0]
}
 80022ec:	bc30      	pop	{r4, r5}
 80022ee:	4770      	bx	lr
    return HAL_ERROR;
 80022f0:	2001      	movs	r0, #1
}
 80022f2:	4770      	bx	lr
  return HAL_OK;
 80022f4:	2000      	movs	r0, #0
}
 80022f6:	bc30      	pop	{r4, r5}
 80022f8:	4770      	bx	lr
    __HAL_TIM_ENABLE(htim);
 80022fa:	6813      	ldr	r3, [r2, #0]
 80022fc:	f043 0301 	orr.w	r3, r3, #1
 8002300:	6013      	str	r3, [r2, #0]
 8002302:	e7f3      	b.n	80022ec <HAL_TIM_Base_Start_IT+0x88>
 8002304:	40010000 	.word	0x40010000
 8002308:	40000800 	.word	0x40000800
 800230c:	40000400 	.word	0x40000400
 8002310:	40000c00 	.word	0x40000c00
 8002314:	40014000 	.word	0x40014000
 8002318:	00010007 	.word	0x00010007

0800231c <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 800231c:	f890 203c 	ldrb.w	r2, [r0, #60]	; 0x3c
 8002320:	2a01      	cmp	r2, #1
 8002322:	d073      	beq.n	800240c <HAL_TIM_ConfigClockSource+0xf0>
 8002324:	4603      	mov	r3, r0
  htim->State = HAL_TIM_STATE_BUSY;
 8002326:	2202      	movs	r2, #2
  tmpsmcr = htim->Instance->SMCR;
 8002328:	6800      	ldr	r0, [r0, #0]
{
 800232a:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(htim);
 800232c:	2401      	movs	r4, #1
  htim->State = HAL_TIM_STATE_BUSY;
 800232e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  __HAL_LOCK(htim);
 8002332:	f883 403c 	strb.w	r4, [r3, #60]	; 0x3c
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8002336:	4c4b      	ldr	r4, [pc, #300]	; (8002464 <HAL_TIM_ConfigClockSource+0x148>)
  tmpsmcr = htim->Instance->SMCR;
 8002338:	6885      	ldr	r5, [r0, #8]
  switch (sClockSourceConfig->ClockSource)
 800233a:	680a      	ldr	r2, [r1, #0]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800233c:	402c      	ands	r4, r5
  switch (sClockSourceConfig->ClockSource)
 800233e:	2a60      	cmp	r2, #96	; 0x60
  htim->Instance->SMCR = tmpsmcr;
 8002340:	6084      	str	r4, [r0, #8]
  switch (sClockSourceConfig->ClockSource)
 8002342:	d065      	beq.n	8002410 <HAL_TIM_ConfigClockSource+0xf4>
 8002344:	d831      	bhi.n	80023aa <HAL_TIM_ConfigClockSource+0x8e>
 8002346:	2a40      	cmp	r2, #64	; 0x40
 8002348:	d048      	beq.n	80023dc <HAL_TIM_ConfigClockSource+0xc0>
 800234a:	d921      	bls.n	8002390 <HAL_TIM_ConfigClockSource+0x74>
 800234c:	2a50      	cmp	r2, #80	; 0x50
 800234e:	d116      	bne.n	800237e <HAL_TIM_ConfigClockSource+0x62>
{
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8002350:	6a06      	ldr	r6, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8002352:	6a05      	ldr	r5, [r0, #32]
      TIM_TI1_ConfigInputStage(htim->Instance,
 8002354:	684c      	ldr	r4, [r1, #4]
  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  tmpccmr1 |= (TIM_ICFilter << 4U);

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8002356:	f026 060a 	bic.w	r6, r6, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800235a:	f025 0501 	bic.w	r5, r5, #1
      TIM_TI1_ConfigInputStage(htim->Instance,
 800235e:	68cf      	ldr	r7, [r1, #12]
  tmpccer |= TIM_ICPolarity;
 8002360:	4334      	orrs	r4, r6
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8002362:	6205      	str	r5, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002364:	6982      	ldr	r2, [r0, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8002366:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800236a:	ea42 1207 	orr.w	r2, r2, r7, lsl #4

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 800236e:	6182      	str	r2, [r0, #24]
  TIMx->CCER = tmpccer;
 8002370:	6204      	str	r4, [r0, #32]
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8002372:	6882      	ldr	r2, [r0, #8]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8002374:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8002378:	f042 0257 	orr.w	r2, r2, #87	; 0x57
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800237c:	6082      	str	r2, [r0, #8]
  __HAL_UNLOCK(htim);
 800237e:	2200      	movs	r2, #0
  htim->State = HAL_TIM_STATE_READY;
 8002380:	2101      	movs	r1, #1
  return HAL_OK;
 8002382:	4610      	mov	r0, r2
  htim->State = HAL_TIM_STATE_READY;
 8002384:	f883 103d 	strb.w	r1, [r3, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8002388:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
}
 800238c:	bcf0      	pop	{r4, r5, r6, r7}
 800238e:	4770      	bx	lr
  switch (sClockSourceConfig->ClockSource)
 8002390:	2a20      	cmp	r2, #32
 8002392:	d002      	beq.n	800239a <HAL_TIM_ConfigClockSource+0x7e>
 8002394:	d91e      	bls.n	80023d4 <HAL_TIM_ConfigClockSource+0xb8>
 8002396:	2a30      	cmp	r2, #48	; 0x30
 8002398:	d1f1      	bne.n	800237e <HAL_TIM_ConfigClockSource+0x62>
  tmpsmcr = TIMx->SMCR;
 800239a:	6881      	ldr	r1, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800239c:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 80023a0:	430a      	orrs	r2, r1
 80023a2:	f042 0207 	orr.w	r2, r2, #7
  TIMx->SMCR = tmpsmcr;
 80023a6:	6082      	str	r2, [r0, #8]
}
 80023a8:	e7e9      	b.n	800237e <HAL_TIM_ConfigClockSource+0x62>
  switch (sClockSourceConfig->ClockSource)
 80023aa:	2a70      	cmp	r2, #112	; 0x70
 80023ac:	d049      	beq.n	8002442 <HAL_TIM_ConfigClockSource+0x126>
 80023ae:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 80023b2:	d1e4      	bne.n	800237e <HAL_TIM_ConfigClockSource+0x62>

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80023b4:	68cc      	ldr	r4, [r1, #12]
 80023b6:	e9d1 5201 	ldrd	r5, r2, [r1, #4]
  tmpsmcr = TIMx->SMCR;
 80023ba:	6881      	ldr	r1, [r0, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80023bc:	432a      	orrs	r2, r5
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80023be:	f421 417f 	bic.w	r1, r1, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80023c2:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
 80023c6:	430a      	orrs	r2, r1

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80023c8:	6082      	str	r2, [r0, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 80023ca:	6882      	ldr	r2, [r0, #8]
 80023cc:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80023d0:	6082      	str	r2, [r0, #8]
      break;
 80023d2:	e7d4      	b.n	800237e <HAL_TIM_ConfigClockSource+0x62>
  switch (sClockSourceConfig->ClockSource)
 80023d4:	f032 0110 	bics.w	r1, r2, #16
 80023d8:	d1d1      	bne.n	800237e <HAL_TIM_ConfigClockSource+0x62>
 80023da:	e7de      	b.n	800239a <HAL_TIM_ConfigClockSource+0x7e>
  tmpccer = TIMx->CCER;
 80023dc:	6a06      	ldr	r6, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80023de:	6a05      	ldr	r5, [r0, #32]
      TIM_TI1_ConfigInputStage(htim->Instance,
 80023e0:	684c      	ldr	r4, [r1, #4]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 80023e2:	f026 060a 	bic.w	r6, r6, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80023e6:	f025 0501 	bic.w	r5, r5, #1
      TIM_TI1_ConfigInputStage(htim->Instance,
 80023ea:	68cf      	ldr	r7, [r1, #12]
  tmpccer |= TIM_ICPolarity;
 80023ec:	4334      	orrs	r4, r6
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80023ee:	6205      	str	r5, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 80023f0:	6982      	ldr	r2, [r0, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 80023f2:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 80023f6:	ea42 1207 	orr.w	r2, r2, r7, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 80023fa:	6182      	str	r2, [r0, #24]
  TIMx->CCER = tmpccer;
 80023fc:	6204      	str	r4, [r0, #32]
  tmpsmcr = TIMx->SMCR;
 80023fe:	6882      	ldr	r2, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8002400:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8002404:	f042 0247 	orr.w	r2, r2, #71	; 0x47
  TIMx->SMCR = tmpsmcr;
 8002408:	6082      	str	r2, [r0, #8]
}
 800240a:	e7b8      	b.n	800237e <HAL_TIM_ConfigClockSource+0x62>
  __HAL_LOCK(htim);
 800240c:	2002      	movs	r0, #2
}
 800240e:	4770      	bx	lr
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8002410:	6a04      	ldr	r4, [r0, #32]
      TIM_TI2_ConfigInputStage(htim->Instance,
 8002412:	684d      	ldr	r5, [r1, #4]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8002414:	f024 0410 	bic.w	r4, r4, #16
      TIM_TI2_ConfigInputStage(htim->Instance,
 8002418:	68ce      	ldr	r6, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800241a:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 800241c:	6981      	ldr	r1, [r0, #24]
  tmpccer = TIMx->CCER;
 800241e:	6a02      	ldr	r2, [r0, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8002420:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8002424:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8002428:	ea41 3106 	orr.w	r1, r1, r6, lsl #12
  tmpccer |= (TIM_ICPolarity << 4U);
 800242c:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  TIMx->CCMR1 = tmpccmr1 ;
 8002430:	6181      	str	r1, [r0, #24]
  TIMx->CCER = tmpccer;
 8002432:	6202      	str	r2, [r0, #32]
  tmpsmcr = TIMx->SMCR;
 8002434:	6882      	ldr	r2, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8002436:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800243a:	f042 0267 	orr.w	r2, r2, #103	; 0x67
  TIMx->SMCR = tmpsmcr;
 800243e:	6082      	str	r2, [r0, #8]
}
 8002440:	e79d      	b.n	800237e <HAL_TIM_ConfigClockSource+0x62>
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8002442:	e9d1 5201 	ldrd	r5, r2, [r1, #4]
 8002446:	68cc      	ldr	r4, [r1, #12]
 8002448:	432a      	orrs	r2, r5
  tmpsmcr = TIMx->SMCR;
 800244a:	6881      	ldr	r1, [r0, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800244c:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8002450:	f421 417f 	bic.w	r1, r1, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8002454:	430a      	orrs	r2, r1
  TIMx->SMCR = tmpsmcr;
 8002456:	6082      	str	r2, [r0, #8]
      tmpsmcr = htim->Instance->SMCR;
 8002458:	6882      	ldr	r2, [r0, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800245a:	f042 0277 	orr.w	r2, r2, #119	; 0x77
      htim->Instance->SMCR = tmpsmcr;
 800245e:	6082      	str	r2, [r0, #8]
      break;
 8002460:	e78d      	b.n	800237e <HAL_TIM_ConfigClockSource+0x62>
 8002462:	bf00      	nop
 8002464:	fffe0088 	.word	0xfffe0088

08002468 <HAL_TIM_OC_DelayElapsedCallback>:
 8002468:	4770      	bx	lr
 800246a:	bf00      	nop

0800246c <HAL_TIM_IC_CaptureCallback>:
 800246c:	4770      	bx	lr
 800246e:	bf00      	nop

08002470 <HAL_TIM_PWM_PulseFinishedCallback>:
 8002470:	4770      	bx	lr
 8002472:	bf00      	nop

08002474 <HAL_TIM_TriggerCallback>:
 8002474:	4770      	bx	lr
 8002476:	bf00      	nop

08002478 <HAL_TIM_IRQHandler>:
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8002478:	6803      	ldr	r3, [r0, #0]
 800247a:	691a      	ldr	r2, [r3, #16]
 800247c:	0791      	lsls	r1, r2, #30
{
 800247e:	b510      	push	{r4, lr}
 8002480:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8002482:	d502      	bpl.n	800248a <HAL_TIM_IRQHandler+0x12>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8002484:	68da      	ldr	r2, [r3, #12]
 8002486:	0792      	lsls	r2, r2, #30
 8002488:	d468      	bmi.n	800255c <HAL_TIM_IRQHandler+0xe4>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 800248a:	691a      	ldr	r2, [r3, #16]
 800248c:	0752      	lsls	r2, r2, #29
 800248e:	d502      	bpl.n	8002496 <HAL_TIM_IRQHandler+0x1e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8002490:	68da      	ldr	r2, [r3, #12]
 8002492:	0750      	lsls	r0, r2, #29
 8002494:	d44f      	bmi.n	8002536 <HAL_TIM_IRQHandler+0xbe>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8002496:	691a      	ldr	r2, [r3, #16]
 8002498:	0711      	lsls	r1, r2, #28
 800249a:	d502      	bpl.n	80024a2 <HAL_TIM_IRQHandler+0x2a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 800249c:	68da      	ldr	r2, [r3, #12]
 800249e:	0712      	lsls	r2, r2, #28
 80024a0:	d437      	bmi.n	8002512 <HAL_TIM_IRQHandler+0x9a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 80024a2:	691a      	ldr	r2, [r3, #16]
 80024a4:	06d0      	lsls	r0, r2, #27
 80024a6:	d502      	bpl.n	80024ae <HAL_TIM_IRQHandler+0x36>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 80024a8:	68da      	ldr	r2, [r3, #12]
 80024aa:	06d1      	lsls	r1, r2, #27
 80024ac:	d41e      	bmi.n	80024ec <HAL_TIM_IRQHandler+0x74>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 80024ae:	691a      	ldr	r2, [r3, #16]
 80024b0:	07d2      	lsls	r2, r2, #31
 80024b2:	d502      	bpl.n	80024ba <HAL_TIM_IRQHandler+0x42>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 80024b4:	68da      	ldr	r2, [r3, #12]
 80024b6:	07d0      	lsls	r0, r2, #31
 80024b8:	d469      	bmi.n	800258e <HAL_TIM_IRQHandler+0x116>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 80024ba:	691a      	ldr	r2, [r3, #16]
 80024bc:	0611      	lsls	r1, r2, #24
 80024be:	d502      	bpl.n	80024c6 <HAL_TIM_IRQHandler+0x4e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 80024c0:	68da      	ldr	r2, [r3, #12]
 80024c2:	0612      	lsls	r2, r2, #24
 80024c4:	d46b      	bmi.n	800259e <HAL_TIM_IRQHandler+0x126>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 80024c6:	691a      	ldr	r2, [r3, #16]
 80024c8:	05d0      	lsls	r0, r2, #23
 80024ca:	d502      	bpl.n	80024d2 <HAL_TIM_IRQHandler+0x5a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 80024cc:	68da      	ldr	r2, [r3, #12]
 80024ce:	0611      	lsls	r1, r2, #24
 80024d0:	d46d      	bmi.n	80025ae <HAL_TIM_IRQHandler+0x136>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 80024d2:	691a      	ldr	r2, [r3, #16]
 80024d4:	0652      	lsls	r2, r2, #25
 80024d6:	d502      	bpl.n	80024de <HAL_TIM_IRQHandler+0x66>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 80024d8:	68da      	ldr	r2, [r3, #12]
 80024da:	0650      	lsls	r0, r2, #25
 80024dc:	d46f      	bmi.n	80025be <HAL_TIM_IRQHandler+0x146>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 80024de:	691a      	ldr	r2, [r3, #16]
 80024e0:	0691      	lsls	r1, r2, #26
 80024e2:	d502      	bpl.n	80024ea <HAL_TIM_IRQHandler+0x72>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 80024e4:	68da      	ldr	r2, [r3, #12]
 80024e6:	0692      	lsls	r2, r2, #26
 80024e8:	d449      	bmi.n	800257e <HAL_TIM_IRQHandler+0x106>
}
 80024ea:	bd10      	pop	{r4, pc}
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 80024ec:	f06f 0110 	mvn.w	r1, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80024f0:	2208      	movs	r2, #8
        HAL_TIM_IC_CaptureCallback(htim);
 80024f2:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 80024f4:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80024f6:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 80024f8:	69db      	ldr	r3, [r3, #28]
 80024fa:	f413 7f40 	tst.w	r3, #768	; 0x300
 80024fe:	d16f      	bne.n	80025e0 <HAL_TIM_IRQHandler+0x168>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002500:	f7ff ffb2 	bl	8002468 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002504:	4620      	mov	r0, r4
 8002506:	f7ff ffb3 	bl	8002470 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800250a:	2200      	movs	r2, #0
 800250c:	6823      	ldr	r3, [r4, #0]
 800250e:	7722      	strb	r2, [r4, #28]
 8002510:	e7cd      	b.n	80024ae <HAL_TIM_IRQHandler+0x36>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8002512:	f06f 0108 	mvn.w	r1, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8002516:	2204      	movs	r2, #4
        HAL_TIM_IC_CaptureCallback(htim);
 8002518:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800251a:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800251c:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800251e:	69db      	ldr	r3, [r3, #28]
 8002520:	079b      	lsls	r3, r3, #30
 8002522:	d15a      	bne.n	80025da <HAL_TIM_IRQHandler+0x162>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002524:	f7ff ffa0 	bl	8002468 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002528:	4620      	mov	r0, r4
 800252a:	f7ff ffa1 	bl	8002470 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800252e:	2200      	movs	r2, #0
 8002530:	6823      	ldr	r3, [r4, #0]
 8002532:	7722      	strb	r2, [r4, #28]
 8002534:	e7b5      	b.n	80024a2 <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8002536:	f06f 0104 	mvn.w	r1, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800253a:	2202      	movs	r2, #2
        HAL_TIM_IC_CaptureCallback(htim);
 800253c:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800253e:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8002540:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8002542:	699b      	ldr	r3, [r3, #24]
 8002544:	f413 7f40 	tst.w	r3, #768	; 0x300
 8002548:	d144      	bne.n	80025d4 <HAL_TIM_IRQHandler+0x15c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800254a:	f7ff ff8d 	bl	8002468 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800254e:	4620      	mov	r0, r4
 8002550:	f7ff ff8e 	bl	8002470 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002554:	2200      	movs	r2, #0
 8002556:	6823      	ldr	r3, [r4, #0]
 8002558:	7722      	strb	r2, [r4, #28]
 800255a:	e79c      	b.n	8002496 <HAL_TIM_IRQHandler+0x1e>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800255c:	f06f 0102 	mvn.w	r1, #2
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8002560:	2201      	movs	r2, #1
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8002562:	6119      	str	r1, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8002564:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8002566:	699b      	ldr	r3, [r3, #24]
 8002568:	0799      	lsls	r1, r3, #30
 800256a:	d130      	bne.n	80025ce <HAL_TIM_IRQHandler+0x156>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800256c:	f7ff ff7c 	bl	8002468 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002570:	4620      	mov	r0, r4
 8002572:	f7ff ff7d 	bl	8002470 <HAL_TIM_PWM_PulseFinishedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002576:	2200      	movs	r2, #0
 8002578:	6823      	ldr	r3, [r4, #0]
 800257a:	7722      	strb	r2, [r4, #28]
 800257c:	e785      	b.n	800248a <HAL_TIM_IRQHandler+0x12>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800257e:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutCallback(htim);
 8002582:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8002584:	611a      	str	r2, [r3, #16]
}
 8002586:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutCallback(htim);
 800258a:	f000 b889 	b.w	80026a0 <HAL_TIMEx_CommutCallback>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800258e:	f06f 0201 	mvn.w	r2, #1
      HAL_TIM_PeriodElapsedCallback(htim);
 8002592:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8002594:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8002596:	f7fe f9e5 	bl	8000964 <HAL_TIM_PeriodElapsedCallback>
 800259a:	6823      	ldr	r3, [r4, #0]
 800259c:	e78d      	b.n	80024ba <HAL_TIM_IRQHandler+0x42>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800259e:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
 80025a2:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 80025a4:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 80025a6:	f000 f87d 	bl	80026a4 <HAL_TIMEx_BreakCallback>
 80025aa:	6823      	ldr	r3, [r4, #0]
 80025ac:	e78b      	b.n	80024c6 <HAL_TIM_IRQHandler+0x4e>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 80025ae:	f46f 7280 	mvn.w	r2, #256	; 0x100
      HAL_TIMEx_Break2Callback(htim);
 80025b2:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 80025b4:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 80025b6:	f000 f877 	bl	80026a8 <HAL_TIMEx_Break2Callback>
 80025ba:	6823      	ldr	r3, [r4, #0]
 80025bc:	e789      	b.n	80024d2 <HAL_TIM_IRQHandler+0x5a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80025be:	f06f 0240 	mvn.w	r2, #64	; 0x40
      HAL_TIM_TriggerCallback(htim);
 80025c2:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80025c4:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 80025c6:	f7ff ff55 	bl	8002474 <HAL_TIM_TriggerCallback>
 80025ca:	6823      	ldr	r3, [r4, #0]
 80025cc:	e787      	b.n	80024de <HAL_TIM_IRQHandler+0x66>
          HAL_TIM_IC_CaptureCallback(htim);
 80025ce:	f7ff ff4d 	bl	800246c <HAL_TIM_IC_CaptureCallback>
 80025d2:	e7d0      	b.n	8002576 <HAL_TIM_IRQHandler+0xfe>
        HAL_TIM_IC_CaptureCallback(htim);
 80025d4:	f7ff ff4a 	bl	800246c <HAL_TIM_IC_CaptureCallback>
 80025d8:	e7bc      	b.n	8002554 <HAL_TIM_IRQHandler+0xdc>
        HAL_TIM_IC_CaptureCallback(htim);
 80025da:	f7ff ff47 	bl	800246c <HAL_TIM_IC_CaptureCallback>
 80025de:	e7a6      	b.n	800252e <HAL_TIM_IRQHandler+0xb6>
        HAL_TIM_IC_CaptureCallback(htim);
 80025e0:	f7ff ff44 	bl	800246c <HAL_TIM_IC_CaptureCallback>
 80025e4:	e791      	b.n	800250a <HAL_TIM_IRQHandler+0x92>
 80025e6:	bf00      	nop

080025e8 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 80025e8:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80025ec:	2b01      	cmp	r3, #1
 80025ee:	d048      	beq.n	8002682 <HAL_TIMEx_MasterConfigSynchronization+0x9a>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 80025f0:	4602      	mov	r2, r0
 80025f2:	2002      	movs	r0, #2

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 80025f4:	6813      	ldr	r3, [r2, #0]
{
 80025f6:	b4f0      	push	{r4, r5, r6, r7}

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 80025f8:	4d23      	ldr	r5, [pc, #140]	; (8002688 <HAL_TIMEx_MasterConfigSynchronization+0xa0>)
  htim->State = HAL_TIM_STATE_BUSY;
 80025fa:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 80025fe:	42ab      	cmp	r3, r5
  tmpcr2 = htim->Instance->CR2;
 8002600:	6858      	ldr	r0, [r3, #4]
  tmpsmcr = htim->Instance->SMCR;
 8002602:	689c      	ldr	r4, [r3, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8002604:	d026      	beq.n	8002654 <HAL_TIMEx_MasterConfigSynchronization+0x6c>
 8002606:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800260a:	42ab      	cmp	r3, r5
 800260c:	d022      	beq.n	8002654 <HAL_TIMEx_MasterConfigSynchronization+0x6c>
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800260e:	4d1f      	ldr	r5, [pc, #124]	; (800268c <HAL_TIMEx_MasterConfigSynchronization+0xa4>)
  tmpcr2 &= ~TIM_CR2_MMS;
 8002610:	f020 0070 	bic.w	r0, r0, #112	; 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8002614:	680e      	ldr	r6, [r1, #0]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8002616:	42ab      	cmp	r3, r5
 8002618:	bf18      	it	ne
 800261a:	f1b3 4f80 	cmpne.w	r3, #1073741824	; 0x40000000
 800261e:	4f1c      	ldr	r7, [pc, #112]	; (8002690 <HAL_TIMEx_MasterConfigSynchronization+0xa8>)
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8002620:	ea40 0006 	orr.w	r0, r0, r6
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8002624:	4e1b      	ldr	r6, [pc, #108]	; (8002694 <HAL_TIMEx_MasterConfigSynchronization+0xac>)
 8002626:	bf0c      	ite	eq
 8002628:	2501      	moveq	r5, #1
 800262a:	2500      	movne	r5, #0
  htim->Instance->CR2 = tmpcr2;
 800262c:	6058      	str	r0, [r3, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800262e:	42bb      	cmp	r3, r7
 8002630:	bf08      	it	eq
 8002632:	f045 0501 	orreq.w	r5, r5, #1
 8002636:	42b3      	cmp	r3, r6
 8002638:	bf14      	ite	ne
 800263a:	4628      	movne	r0, r5
 800263c:	f045 0001 	orreq.w	r0, r5, #1
 8002640:	4d15      	ldr	r5, [pc, #84]	; (8002698 <HAL_TIMEx_MasterConfigSynchronization+0xb0>)
 8002642:	42ab      	cmp	r3, r5
 8002644:	bf08      	it	eq
 8002646:	f040 0001 	orreq.w	r0, r0, #1
 800264a:	b960      	cbnz	r0, 8002666 <HAL_TIMEx_MasterConfigSynchronization+0x7e>
 800264c:	4813      	ldr	r0, [pc, #76]	; (800269c <HAL_TIMEx_MasterConfigSynchronization+0xb4>)
 800264e:	4283      	cmp	r3, r0
 8002650:	d009      	beq.n	8002666 <HAL_TIMEx_MasterConfigSynchronization+0x7e>
 8002652:	e00d      	b.n	8002670 <HAL_TIMEx_MasterConfigSynchronization+0x88>
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8002654:	e9d1 5600 	ldrd	r5, r6, [r1]
    tmpcr2 &= ~TIM_CR2_MMS2;
 8002658:	f420 0070 	bic.w	r0, r0, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 800265c:	4330      	orrs	r0, r6
  tmpcr2 &= ~TIM_CR2_MMS;
 800265e:	f020 0070 	bic.w	r0, r0, #112	; 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8002662:	4328      	orrs	r0, r5
  htim->Instance->CR2 = tmpcr2;
 8002664:	6058      	str	r0, [r3, #4]
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8002666:	6889      	ldr	r1, [r1, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
 8002668:	f024 0480 	bic.w	r4, r4, #128	; 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800266c:	430c      	orrs	r4, r1

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 800266e:	609c      	str	r4, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 8002670:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 8002672:	2101      	movs	r1, #1

  return HAL_OK;
 8002674:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
 8002676:	f882 103d 	strb.w	r1, [r2, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 800267a:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
}
 800267e:	bcf0      	pop	{r4, r5, r6, r7}
 8002680:	4770      	bx	lr
  __HAL_LOCK(htim);
 8002682:	2002      	movs	r0, #2
}
 8002684:	4770      	bx	lr
 8002686:	bf00      	nop
 8002688:	40010000 	.word	0x40010000
 800268c:	40000400 	.word	0x40000400
 8002690:	40000800 	.word	0x40000800
 8002694:	40000c00 	.word	0x40000c00
 8002698:	40014000 	.word	0x40014000
 800269c:	40001800 	.word	0x40001800

080026a0 <HAL_TIMEx_CommutCallback>:
 80026a0:	4770      	bx	lr
 80026a2:	bf00      	nop

080026a4 <HAL_TIMEx_BreakCallback>:
 80026a4:	4770      	bx	lr
 80026a6:	bf00      	nop

080026a8 <HAL_TIMEx_Break2Callback>:
 80026a8:	4770      	bx	lr
 80026aa:	bf00      	nop

080026ac <__libc_init_array>:
 80026ac:	b570      	push	{r4, r5, r6, lr}
 80026ae:	4d0d      	ldr	r5, [pc, #52]	; (80026e4 <__libc_init_array+0x38>)
 80026b0:	4c0d      	ldr	r4, [pc, #52]	; (80026e8 <__libc_init_array+0x3c>)
 80026b2:	1b64      	subs	r4, r4, r5
 80026b4:	10a4      	asrs	r4, r4, #2
 80026b6:	2600      	movs	r6, #0
 80026b8:	42a6      	cmp	r6, r4
 80026ba:	d109      	bne.n	80026d0 <__libc_init_array+0x24>
 80026bc:	4d0b      	ldr	r5, [pc, #44]	; (80026ec <__libc_init_array+0x40>)
 80026be:	4c0c      	ldr	r4, [pc, #48]	; (80026f0 <__libc_init_array+0x44>)
 80026c0:	f000 f820 	bl	8002704 <_init>
 80026c4:	1b64      	subs	r4, r4, r5
 80026c6:	10a4      	asrs	r4, r4, #2
 80026c8:	2600      	movs	r6, #0
 80026ca:	42a6      	cmp	r6, r4
 80026cc:	d105      	bne.n	80026da <__libc_init_array+0x2e>
 80026ce:	bd70      	pop	{r4, r5, r6, pc}
 80026d0:	f855 3b04 	ldr.w	r3, [r5], #4
 80026d4:	4798      	blx	r3
 80026d6:	3601      	adds	r6, #1
 80026d8:	e7ee      	b.n	80026b8 <__libc_init_array+0xc>
 80026da:	f855 3b04 	ldr.w	r3, [r5], #4
 80026de:	4798      	blx	r3
 80026e0:	3601      	adds	r6, #1
 80026e2:	e7f2      	b.n	80026ca <__libc_init_array+0x1e>
 80026e4:	0800273c 	.word	0x0800273c
 80026e8:	0800273c 	.word	0x0800273c
 80026ec:	0800273c 	.word	0x0800273c
 80026f0:	08002748 	.word	0x08002748

080026f4 <memset>:
 80026f4:	4402      	add	r2, r0
 80026f6:	4603      	mov	r3, r0
 80026f8:	4293      	cmp	r3, r2
 80026fa:	d100      	bne.n	80026fe <memset+0xa>
 80026fc:	4770      	bx	lr
 80026fe:	f803 1b01 	strb.w	r1, [r3], #1
 8002702:	e7f9      	b.n	80026f8 <memset+0x4>

08002704 <_init>:
 8002704:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002706:	bf00      	nop
 8002708:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800270a:	bc08      	pop	{r3}
 800270c:	469e      	mov	lr, r3
 800270e:	4770      	bx	lr

08002710 <_fini>:
 8002710:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002712:	bf00      	nop
 8002714:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002716:	bc08      	pop	{r3}
 8002718:	469e      	mov	lr, r3
 800271a:	4770      	bx	lr
